// Copyright Semaeopus Ltd. 2017
// This code was created as part of LevelKit on: 2019-11-26 - 9:25
// DO NOT EDIT THIS FILE - Code changes will NOT be picked up and may break your project
// Visit http://wiki.offgridthegame.com for help - Happy Hacking!

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEditor;
using System.Linq;

namespace NavCloud
{
    public static class Generator
    {
        private static float progress = 0.0f;
        private static string statusText = string.Empty;
        
        private static int totalEstimatedRecursions = 1;
        private static int subdivisions = 0;

        [MenuItem("Off Grid/Generate NavCloud")]
        public static void GenerateNavCloud()
        {
            // clear up any pre existing navRoot-ery
            GameObject navRoot = GameObject.Find("NavCloud");
            if (navRoot != null)
            {
                GameObject.DestroyImmediate(navRoot);
            }

            // start afresh
            navRoot = new GameObject("NavCloud");

            NavCloudBoundaries[] multipleNavCloudBoundaries = GameObject.FindObjectsOfType<NavCloudBoundaries>();
            NavCloudBoundaries navCloudBoundaries = null;
            Bounds extents = new Bounds();
            bool completeGeneration = false;
            bool withBoundaries = false;

            if (multipleNavCloudBoundaries.Length > 1)
            {
                if (EditorUtility.DisplayDialog("Warning!",
                "More than one NavCloudBoundary component was found in the scene.\n" +
                    "Only the first component found will be considered\nDo you want to continue?", "Yes", "No"))
                {
                    completeGeneration = true;
                    withBoundaries = true;
                }
            }

            else if (multipleNavCloudBoundaries.Length <= 0)
            {
                if (EditorUtility.DisplayDialog("Warning!",
                "No NavCloudBoundary component was found in the scene.\n" +
                    "It will generate a NavCloud for all the level (can take a while).\nDo you want to continue?", "Yes", "No"))
                {
                    completeGeneration = true;
                }
            }

            else
            {
                completeGeneration = true;
                withBoundaries = true;
            }


            if (completeGeneration)
            {
                if(!withBoundaries)
                { 
                // next job. Find extents.
                var renderers = GameObject.FindObjectsOfType<Renderer>();

                extents = new Bounds(Vector3.zero, Vector3.zero);

                foreach (Renderer r in renderers)
                {
                        //bool checkRenderer = false;
                        //if (navCloudBoundaries != null) { checkRenderer = navCloudBoundaries.IsIntersecting(r); }
                        //else { checkRenderer = true; }

                        //if (checkRenderer)
                        {
                        if (r.gameObject.layer == LayerMask.NameToLayer("level"))
                        {
                            extents.Encapsulate(r.bounds);
                        }
                    }
                }

                    // make it a cube
                    float maxDim = Mathf.Max(extents.size.x, extents.size.y, extents.size.z);
                    float minY = extents.center.y - extents.extents.y;
                    extents.size = new Vector3(maxDim, maxDim, maxDim);
                    Vector3 centre = extents.center;
                    centre.y = minY + extents.extents.y;
                    extents.center = centre;
                }

                else // Boundaries is used here //
                {
                    navCloudBoundaries = multipleNavCloudBoundaries[0];
                    navCloudBoundaries.UpdateExternalBounds(out extents);

                    float maxDim = Mathf.Max(extents.size.x, extents.size.y, extents.size.z);
                    extents.size = new Vector3(maxDim, maxDim, maxDim);
                }


                // stuff to display to the user
                totalEstimatedRecursions = 1;
                subdivisions = 0;
                float blah = extents.size.x / NavCloudVolume.minimumSize;
                while (blah > 1.0f)
                {
                    blah /= 2.0f;
                    totalEstimatedRecursions++;
                }

                NavCloudComponent cloud = navRoot.AddComponent<NavCloudComponent>();

                // top level of the octree
                GameObject top = new GameObject("NavTop");
                top.transform.position = extents.center;
                top.transform.parent = navRoot.transform;
                BoxCollider box = top.AddComponent<BoxCollider>();
                box.size = extents.size;
                box.isTrigger = true;

                int index = 0;
                Subdivide(top, box, 0, ref index);

                Graphify(top);

                BoxCollider[] boxes = top.GetComponentsInChildren<BoxCollider>();
                Debug.Log(boxes.Length);
                for (int i = 0; i < boxes.Count(); ++i)
                {
                    GameObject.DestroyImmediate(boxes[i]);
                }

                cloud.ProcessHierarchy(top);

                string scenePath = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(SceneManager.GetActiveScene().path), "NavCloud.asset");
                AssetDatabase.CreateAsset(cloud.data, scenePath);
                AssetDatabase.SaveAssets();


                GameObject.DestroyImmediate(top);

                EditorUtility.ClearProgressBar();
            }
        }

        static bool Subdivide(GameObject toDivide, BoxCollider collider, int depth, ref int id, NavCloudBoundaries boundaries = null)
        {
            int nextDepth = depth + 1;

            progress = (float)depth / (float)totalEstimatedRecursions;
            statusText = "Performing subdivision " + subdivisions + " of a possible " + totalEstimatedRecursions;
            EditorUtility.DisplayProgressBar("Generating Cloud", statusText, progress);

            NavCloudNode node = toDivide.AddComponent<NavCloudNode>();
            node.id = id;
            id++;
            
            if (Physics.CheckBox(toDivide.transform.position, collider.bounds.extents, toDivide.transform.rotation, -1, QueryTriggerInteraction.Ignore))
            {   // This cube has collisions in. Divide it until it either doesn't or is small enough that we can tolerate its continued existence

                // halve the extents
                Vector3 half = collider.size * 0.5f;
                Vector3 quarter = half * 0.5f;
                if (half.x < NavCloudVolume.minimumSize)
                {
                    return false;
                }
                
                Vector3 offset = new Vector3(-quarter.x, quarter.y, quarter.z);

                // Here's my notation. Upper is higher in y, Far is higher in Z, Right is higher in X:
                // UFL - Upper Far Left
                // UFR - Upper Far Right
                // UNR - Upper Near Right
                // UNL - Upper Near Left
                // LFL - Lower Far Left
                // LFR - Lower Far Right
                // LNR - Lower Near Right
                // LNL - Lower Near Left

                bool success = false;
                {
                    GameObject UFL = new GameObject("UFL_" + depth);
                    UFL.transform.position = toDivide.transform.position + offset;
                    UFL.transform.parent = toDivide.transform;
                    BoxCollider box = UFL.AddComponent<BoxCollider>();
                    box.size = half;
                    box.isTrigger = true;
                    NavCloudVolume navVolume = UFL.AddComponent<NavCloudVolume>();
                    navVolume.depth = depth;
                    navVolume.size = half.x;
                    bool s = Subdivide(UFL, box, nextDepth, ref id);
                    success |= s;
                    

                    if (s)
                    {
                        node.UFL = UFL.GetComponent<NavCloudNode>();

                        // so the subdivision is successful AND we have created children. Therefore this is not a navVolume, and doesn't need or deserve these components.
                        if (UFL.transform.childCount > 0)
                        {
                            GameObject.DestroyImmediate(box);
                        }
                    }
                    else // if it isn't, then we should destroy this 
                    {
                        GameObject.DestroyImmediate(UFL);
                        --id;
                    }
                }

                {
                    offset.x = quarter.x;
                    GameObject UFR = new GameObject("UFR_" + depth);
                    UFR.transform.position = toDivide.transform.position + offset;
                    UFR.transform.parent = toDivide.transform;
                    BoxCollider box = UFR.AddComponent<BoxCollider>();
                    box.size = half;
                    box.isTrigger = true;
                    NavCloudVolume navVolume = UFR.AddComponent<NavCloudVolume>();
                    navVolume.depth = depth;
                    navVolume.size = half.x;
                    bool s = Subdivide(UFR, box, nextDepth, ref id);
                    success |= s;

                    if (s)
                    {
                        node.UFR = UFR.GetComponent<NavCloudNode>();

                        if (UFR.transform.childCount > 0)
                        {
                            GameObject.DestroyImmediate(box);
                        }
                    }
                    else
                    {
                        GameObject.DestroyImmediate(UFR);
                        --id;
                    }
                }

                {
                    offset.z = -quarter.z;
                    GameObject UNR = new GameObject("UNR_" + depth);
                    UNR.transform.position = toDivide.transform.position + offset;
                    UNR.transform.parent = toDivide.transform;
                    BoxCollider box = UNR.AddComponent<BoxCollider>();
                    box.size = half;
                    box.isTrigger = true;
                    NavCloudVolume navVolume = UNR.AddComponent<NavCloudVolume>();
                    navVolume.depth = depth;
                    navVolume.size = half.x;
                    bool s = Subdivide(UNR, box, nextDepth, ref id);
                    success |= s;

                    if (s)
                    {
                        node.UNR = UNR.GetComponent<NavCloudNode>();

                        if (UNR.transform.childCount > 0)
                        {
                            GameObject.DestroyImmediate(box);
                        }
                    }
                    else
                    {
                        GameObject.DestroyImmediate(UNR);
                        --id;
                    }
                }

                {
                    offset.x = -quarter.x;
                    GameObject UNL = new GameObject("UNL_" + depth);
                    UNL.transform.position = toDivide.transform.position + offset;
                    UNL.transform.parent = toDivide.transform;
                    BoxCollider box = UNL.AddComponent<BoxCollider>();
                    box.size = half;
                    box.isTrigger = true;
                    NavCloudVolume navVolume = UNL.AddComponent<NavCloudVolume>();
                    navVolume.depth = depth;
                    navVolume.size = half.x;
                    bool s = Subdivide(UNL, box, nextDepth, ref id);
                    success |= s;

                    if (s)
                    {
                        node.UNL = UNL.GetComponent<NavCloudNode>();

                        if (UNL.transform.childCount > 0)
                        {
                            GameObject.DestroyImmediate(box);
                        }
                    }
                    else
                    {
                        GameObject.DestroyImmediate(UNL);
                        --id;
                    }
                }

                offset.y = -quarter.y;

                {
                    offset.z = quarter.z;
                    GameObject LFL = new GameObject("LFL_" + depth);
                    LFL.transform.position = toDivide.transform.position + offset;
                    LFL.transform.parent = toDivide.transform;
                    BoxCollider box = LFL.AddComponent<BoxCollider>();
                    box.size = half;
                    box.isTrigger = true;
                    NavCloudVolume navVolume = LFL.AddComponent<NavCloudVolume>();
                    navVolume.depth = depth;
                    navVolume.size = half.x;
                    bool s = Subdivide(LFL, box, nextDepth, ref id);
                    success |= s;

                    if (s)
                    {
                        node.LFL = LFL.GetComponent<NavCloudNode>();

                        if (LFL.transform.childCount > 0)
                        {
                            GameObject.DestroyImmediate(box);
                        }
                    }
                    else
                    {
                        GameObject.DestroyImmediate(LFL);
                        --id;
                    }
                }

                {
                    offset.x = quarter.x;
                    GameObject LFR = new GameObject("LFR_" + depth);
                    LFR.transform.position = toDivide.transform.position + offset;
                    LFR.transform.parent = toDivide.transform;
                    BoxCollider box = LFR.AddComponent<BoxCollider>();
                    box.size = half;
                    box.isTrigger = true;
                    NavCloudVolume navVolume = LFR.AddComponent<NavCloudVolume>();
                    navVolume.depth = depth;
                    navVolume.size = half.x;
                    bool s = Subdivide(LFR, box, nextDepth, ref id);
                    success |= s;

                    if (s)
                    {
                        node.LFR = LFR.GetComponent<NavCloudNode>();

                        if (LFR.transform.childCount > 0)
                        {
                            GameObject.DestroyImmediate(box);
                        }
                    }
                    else
                    {
                        GameObject.DestroyImmediate(LFR);
                        --id;
                    }
                }

                {
                    offset.z = -quarter.z;
                    GameObject LNR = new GameObject("LNR_" + depth);
                    LNR.transform.position = toDivide.transform.position + offset;
                    LNR.transform.parent = toDivide.transform;
                    BoxCollider box = LNR.AddComponent<BoxCollider>();
                    box.size = half;
                    box.isTrigger = true;
                    NavCloudVolume navVolume = LNR.AddComponent<NavCloudVolume>();
                    navVolume.depth = depth;
                    navVolume.size = half.x;
                    bool s = Subdivide(LNR, box, nextDepth, ref id);
                    success |= s;

                    if (s)
                    {
                        node.LNR = LNR.GetComponent<NavCloudNode>();

                        if (LNR.transform.childCount > 0)
                        {
                            GameObject.DestroyImmediate(box);
                        }
                    }
                    else
                    {
                        GameObject.DestroyImmediate(LNR);
                        --id;
                    }
                }

                {
                    offset.x = -quarter.x;
                    GameObject LNL = new GameObject("LNL_" + depth);
                    LNL.transform.position = toDivide.transform.position + offset;
                    LNL.transform.parent = toDivide.transform;
                    BoxCollider box = LNL.AddComponent<BoxCollider>();
                    box.size = half;
                    box.isTrigger = true;
                    NavCloudVolume navVolume = LNL.AddComponent<NavCloudVolume>();
                    navVolume.depth = depth;
                    navVolume.size = half.x;
                    bool s = Subdivide(LNL, box, nextDepth, ref id);
                    success |= s;

                    if (s)
                    {
                        node.LNL = LNL.GetComponent<NavCloudNode>();

                        if (LNL.transform.childCount > 0)
                        {
                            GameObject.DestroyImmediate(box);
                        }
                    }
                    else
                    {
                        GameObject.DestroyImmediate(LNL);
                        --id;
                    }
                }

                return success; // this is true if ANY of the subdivides have reported success (i.e. eventually led to a collision-less volume).
            }
            else
            {
                return true; // no collision for this volume, so it's as small as it needs to be.
            }
        }

        static void Graphify(GameObject top)
        {
            // First job. Grab everything with a NavCloudVolume. These are the nodes that we need to generate adjacency for.
            NavCloudVolume[] nodes = Object.FindObjectsOfType<NavCloudVolume>();

            int total = nodes.Count();
            for (int i = 0; i < total; ++i)
            {
                NavCloudVolume n = nodes[i];
                statusText = "Determining adjacenecy for navVolume " + i;
                progress = 0.5f + ((float)i / (float)total / 2.0f);

                EditorUtility.DisplayProgressBar("Graphifying", statusText, progress);
                n.DetermineAdjacency(nodes);
            }


        }


#if GAME_CORE
        [MenuItem("Off Grid/Test NavCloud")]
        static void Test()
        {
            NavCloudVolume[] nodes = Object.FindObjectsOfType<NavCloudVolume>();
            if (nodes.Count() > 0)
            {
                int rand1 = Random.Range(0, nodes.Count() - 1);
                int rand2 = Random.Range(0, nodes.Count() - 1);

                NavCloudVolume a = nodes[rand1];
                NavCloudVolume b = nodes[rand2];

                List<NavCloudVolume> path = a.FindRouteFrom(b);

                for (int i = 0; i < path.Count() - 1; ++i)
                {
                    NavCloudVolume n = path[i];
                    NavCloudVolume nn = path[i + 1];

                    Debug.DrawLine(n.gameObject.transform.position, nn.gameObject.transform.position, Color.red, 60.0f, true);
                }
            }
        }
#endif
    }
}
