// Copyright Semaeopus Ltd. 2017
// This code was created as part of LevelKit on: 2019-11-26 - 9:25
// DO NOT EDIT THIS FILE - Code changes will NOT be picked up and may break your project
// Visit http://wiki.offgridthegame.com for help - Happy Hacking!

#if LEVEL_KIT && UNITY_EDITOR
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using System.IO;
using UnityEditor.AI;
using UnityEditor.VersionControl;

public static class LevelKitUtils
{
    /// <summary>
    ///  Remove readonly attributes to contents of a folder, optionally recursive
    /// </summary>
    /// <param name="targetDir"></param>
    /// <param name="recursive"></param>
    public static void RemoveReadonly(string targetDir, bool recursive) 
    {
        ModifyReadOnly(targetDir, recursive, false);
    }
    
    /// <summary>
    ///  Add readonly attributes to contents of a folder, optionally recursive
    /// </summary>
    /// <param name="targetDir"></param>
    /// <param name="recursive"></param>
    public static void AddReadonly(string targetDir, bool recursive) 
    {
        ModifyReadOnly(targetDir, recursive, true);
    }
    
    /// <summary>
    /// Base logic for AddReadonly/RemoveReadonly
    /// </summary>
    /// <param name="targetDir"></param>
    /// <param name="recursive"></param>
    /// <param name="isReadonly"></param>
    private static void ModifyReadOnly(string targetDir, bool recursive, bool isReadonly)
    {
        DirectoryInfo dir = new DirectoryInfo(targetDir);
        if (dir.Exists)
        {
            foreach (FileInfo file in dir.GetFiles()) 
            {
                file.IsReadOnly = isReadonly;
            }

            if (recursive) 
            {
                foreach (DirectoryInfo subdir in dir.GetDirectories()) 
                {
                    RemoveReadonly(subdir.FullName, true);
                }
            }
        }
    }

    /// <summary>
    /// Copy a directory and its contents to target location, takes paths as strings
    /// </summary>
    /// <param name="source"></param>
    /// <param name="target"></param>
    /// <param name="shouldCopyFile"></param>
    /// <param name="shouldCopyDir"></param>
    /// <returns></returns>
    public static bool CopyDirectory(string source, string target, Func<FileInfo, bool> shouldCopyFile = null, Func<DirectoryInfo, bool> shouldCopyDir= null)
    {
        return CopyDirectory(new DirectoryInfo(source), new DirectoryInfo(target), shouldCopyFile, shouldCopyDir);
    }

    /// <summary>
    /// Copy a directory and its contents to target location, takes paths as DirectoryInfo
    /// </summary>
    /// <param name="source"></param>
    /// <param name="target"></param>
    /// <param name="shouldCopyFile"></param>
    /// <param name="shouldCopyDir"></param>
    /// <returns></returns>
    public static bool CopyDirectory(DirectoryInfo source, DirectoryInfo target, Func<FileInfo, bool> shouldCopyFile = null, Func<DirectoryInfo, bool> shouldCopyDir= null)
    {
        bool result = true;

        try
        {
            Directory.CreateDirectory(target.FullName);

            foreach (FileInfo file in source.GetFiles())
            {
                if (shouldCopyFile == null || shouldCopyFile(file))
                {
                    file.CopyTo(Path.Combine(target.FullName, file.Name), true);
                }
            }

            foreach (DirectoryInfo sourceSubDir in source.GetDirectories())
            {
                if (shouldCopyDir == null || shouldCopyDir(sourceSubDir))
                {
                    DirectoryInfo nextTargetSubDir = target.CreateSubdirectory(sourceSubDir.Name);
                    CopyDirectory(sourceSubDir, nextTargetSubDir, shouldCopyFile, shouldCopyDir);
                }
            }
        }
        catch (Exception e)
        {
            Debug.LogErrorFormat("Failed to copy dir \"{0}\" to \"{1}\" - {2}", source.FullName, target.FullName, e.Message);
            result = false;
        }
        
        return result;
    }

    /// <summary>
    /// Empty the contents of a directory
    /// </summary>
    /// <param name="path"></param>
    public static void EmptyDirectory(string path)
    {
        if (Directory.Exists(path))
        {
            foreach (string file in Directory.GetFiles(path))
            {
                File.Delete(file);
            }
            foreach (string dir in Directory.GetDirectories(path))
            {
                Directory.Delete(dir, true);
            }
        }
    }
    
    /// <summary>
    /// Cached list of reasons the editor could be busy
    /// </summary>
    private static readonly List<string> busyReasonse = new List<string>(4);
    
    /// <summary>
    /// Is the editor busy with a task? If so fill in "reason"
    /// </summary>
    /// <param name="reason"></param>
    /// <returns></returns>
    public static bool IsEditorBusy(out string reason)
    {
        reason = string.Empty;
        busyReasonse.Clear();
        if (Lightmapping.isRunning)
        {
            busyReasonse.Add("Building Lightmaps");
        }
        if (NavMeshBuilder.isRunning)
        {
            busyReasonse.Add("Building NavMesh");
        }
        if (EditorApplication.isCompiling)
        {
            busyReasonse.Add("Compiling");
        }
        if (EditorApplication.isPlayingOrWillChangePlaymode)
        {
            busyReasonse.Add("In Play Mode");
        }

        if (busyReasonse.Count > 0)
        {
            reason = string.Join(", ", busyReasonse.ToArray());
            return true;
        }

        return false;
    }
    
    /// <summary>
    /// Draw a gui that edits a LevelDefinition
    /// </summary>
    /// <param name="level"></param>
    public static void DrawEditiableLevelDefinition(LevelDefinition level)
    {
		List<string>_districts = new List<string> { "Residential", "Commercial", "Government", "Financial", "Industrial", "Harbour", "Map" };
		int _districtChoiceIndex = string.IsNullOrEmpty(level.district) ? 0 : _districts.IndexOf(level.district);

		EditorGUILayout.BeginVertical("Box");

        level.name = EditorGUILayout.TextField("Level Name", level.name);
        level.description = EditorGUILayout.TextField("Level Description", level.description);
		_districtChoiceIndex = EditorGUILayout.Popup("District", _districtChoiceIndex, _districts.ToArray());
		level.district = _districts[_districtChoiceIndex];
        level.location = EditorGUILayout.TextField("Location", level.location);

        EditorGUILayout.EndVertical();
    }

    /// <summary>
    /// Check out a path with version control
    /// </summary>
    /// <param name="path"></param>
    public static bool VCSCheckoutPath(string path)
    {
        string projectRoot = new DirectoryInfo(Application.dataPath).Parent.FullName;

        if (path.StartsWith(projectRoot))
        {
            // Remove unity root from path
            path = path.Substring(projectRoot.Length + 1); 
        }

        if (File.Exists(path))
        {
            Asset vcsAsset = Provider.GetAssetByPath(path);

            bool assetUnderVersionControl = vcsAsset != null &&
                                         (vcsAsset.IsState(Asset.States.Synced) ||
                                          vcsAsset.IsState(Asset.States.OutOfSync) ||
                                          vcsAsset.IsState(Asset.States.AddedLocal));
            
            // Check if the asset is valid, under version control and that version control is active
            if (vcsAsset != null 
                && assetUnderVersionControl
                && Provider.isActive)
            {
                if (Provider.CheckoutIsValid(vcsAsset, CheckoutMode.Asset))
                {
                    Task checkoutTask = Provider.Checkout(vcsAsset, CheckoutMode.Asset);
                    checkoutTask.Wait();
                    
                    return checkoutTask.success;
                }
                
                // If checkout is not valid, return if the asset is already checked out or has been added
                return vcsAsset.IsOneOfStates(new []{Asset.States.CheckedOutLocal, Asset.States.AddedLocal});
            }
            
            // Otherwise just check that we can edit it
            return new FileInfo(path).IsReadOnly == false;
        }
        
        Debug.LogErrorFormat("Failed to check out '{0}' no such file exists", path);
        return false;
    }

    /// <summary>
    /// Static cached GUIContent
    /// </summary>
    private static readonly GUIContent sTempGuiContent = new GUIContent();

    /// <summary>
    /// Allows the user to set the values in a cached GUIContent to avoid allocations
    /// </summary>
    /// <param name="text"></param>
    /// <param name="tooltip"></param>
    /// <returns></returns>
    public static GUIContent TempGUIContent(string text, string tooltip)
    {
        sTempGuiContent.text = text;
        sTempGuiContent.tooltip = tooltip;
        return sTempGuiContent;
    }
}


#endif // LEVEL_KIT && UNITY_EDITOR
