// Copyright Semaeopus Ltd. 2017
// This code was created as part of LevelKit on: 2019-11-26 - 9:25
// DO NOT EDIT THIS FILE - Code changes will NOT be picked up and may break your project
// Visit http://wiki.offgridthegame.com for help - Happy Hacking!

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;
using UnityEditor;


public class ProbeLocation {

	public Vector3 point;
	public bool used = false;

	public ProbeLocation(Vector3 p, bool u) {
		point = p;
		used = u;
	}
}

public static class LightProbePlacement 
{
	private static float progress = 0.0f;
	private static string statusText = string.Empty;

	public static float mergeDistance = 1;
	
#if GAME_CORE
	[MenuItem("Off Grid/Generate LightProbes")]
#endif // GAME_CORE
	public static void PlaceProbes() 
	{
		LightProbeGroup probeGroup = Object.FindObjectOfType<LightProbeGroup>() 
		                             ?? new GameObject("LightProbeGroup").AddComponent<LightProbeGroup>();
		
		progress = 0.0f;

		statusText = "Triangulating NavMesh...";
		EditorUtility.DisplayProgressBar("Generating LightProbes", statusText, progress);

		// Let's make sure the Probe gropup object is at (0,0,0) so it matches with NavMesh coordinates:
		probeGroup.transform.position = Vector3.zero;

		// Get NavMesh data:
		statusText = "Collecting scene data...";
		EditorUtility.DisplayProgressBar("Generating LightProbes", statusText, progress);
		NavMeshTriangulation navMesh = NavMesh.CalculateTriangulation();

		// Determine probe  locations:
		List<ProbeLocation> probeLocations = DetermineProbeLocations(navMesh);
		EditorUtility.DisplayProgressBar("Generating LightProbes", statusText, progress);

		// Check the distance to other nearby probes:
		// TODO: This is pretty much as unoptimized brute force as something can be. We should do something a bit smarter or large scenees will take forever.
		// Quadtree to store locatiosn so we only need to compare with nearby locations instead of all?
		List<Vector3> mergedProbes = new List<Vector3>();
		int probeListLength = probeLocations.Count;

		int done = 0;
		foreach (ProbeLocation location in probeLocations) 
		{
			if (location.used == false) 
			{
				progress = (float)done / (float)probeListLength;
				EditorUtility.DisplayProgressBar("Generating LightProbes", statusText, progress);
				List<Vector3> nearbyProbes = new List<Vector3> {location.point};
				location.used = true;
				foreach (ProbeLocation otherLocation in probeLocations) {
					if (otherLocation.used == false) {
						statusText = string.Format("Checking point {0}/{1}", done, probeListLength);
						
						if (Vector3.Distance(otherLocation.point, location.point) <= mergeDistance) {
							otherLocation.used = true;
							nearbyProbes.Add(otherLocation.point);
						}
					}
				}

				// Merge nearby probe locations together:
				Vector3 newLocation = new Vector3();
				foreach (Vector3 probeLocation in nearbyProbes) 
				{
					newLocation += probeLocation;
				}
				newLocation /= nearbyProbes.Count;

				// Add this location:
				mergedProbes.Add(newLocation);

				// Add secondary probe above this location:
				int walkFlyMask = 1 << NavMesh.GetAreaFromName("WalkableAndFlyable");
				int flyMask = 1 << NavMesh.GetAreaFromName("Flyable");
				int navMeshMask = walkFlyMask | flyMask;
				float deltaHeight = 2.25f;
				NavMeshHit hit;
				if (NavMesh.SamplePosition(newLocation, out hit, 0.5f, navMeshMask)) {
					deltaHeight = 5f;
				}

				Vector3 secondaryPosition = new Vector3(newLocation.x, newLocation.y + deltaHeight, newLocation.z);
				mergedProbes.Add(secondaryPosition);
				//done += 1;
				done += nearbyProbes.Count;
			}
		}

		statusText = "Final steps...";
		EditorUtility.DisplayProgressBar("Generating LightProbes", statusText, progress);

		// assign probe locations to LightProbeGroup:
		probeGroup.probePositions = mergedProbes.ToArray();
		EditorUtility.DisplayProgressBar("Generating LightProbes", statusText, progress);

		EditorUtility.ClearProgressBar();
	}

	// Create a list of ProbeLocations using NavMesh vertices & polygon centroids
	private static List<ProbeLocation> DetermineProbeLocations(NavMeshTriangulation mesh) {

		List<ProbeLocation> probeLocations = new List<ProbeLocation>();
		
		// NavMesh corners:
		foreach (Vector3 vert in mesh.vertices) {
			probeLocations.Add(new ProbeLocation(new Vector3(vert.x, vert.y + 0.25f, vert.z), false));
		}
		
		// NaveMesh tri centers:
		// create & normalize barycenric center coordinate:
		Vector3 barycentric = new Vector3(0.5f, 0.5f, 0.5f);
		float sum = barycentric.x + barycentric.y + barycentric.z;
		barycentric /= sum;
		// loop through prolygons in the mesh:
		for (int i = 0; i < mesh.indices.Length / 3; i++) {
			// Get the polygon vertices:
			Vector3[] points = new Vector3[3];
			points[0] = mesh.vertices[mesh.indices[i * 3 + 0]];
			points[1] = mesh.vertices[mesh.indices[i * 3 + 1]];
			points[2] = mesh.vertices[mesh.indices[i * 3 + 2]];
			// Calulate barycentric center & convert to local coordinates:
			Vector3 polyCentroid = barycentric.x * points[0] + barycentric.y * points[1] + barycentric.z * points[2];
			// Add the location
			probeLocations.Add(new ProbeLocation(new Vector3(polyCentroid.x, polyCentroid.y + 0.25f, polyCentroid.z), false));
		}
		return probeLocations;
	}

}

