// Copyright Semaeopus Ltd. 2017
// This code was created as part of LevelKit on: 2019-11-26 - 9:25
// DO NOT EDIT THIS FILE - Code changes will NOT be picked up and may break your project
// Visit http://wiki.offgridthegame.com for help - Happy Hacking!

#if LEVEL_KIT && UNITY_EDITOR
using System;
using UnityEngine;
using UnityEditor;
using UnityEditor.AI;
using System.IO;
using System.Linq;
using UnityEditor.SceneManagement;
using UnityEngine.SceneManagement;

[System.Serializable]
public class LevelKitTab_Build : LevelKitTabBase
{
    [SerializeField]
    private bool buildLightMaps = false;

    [SerializeField]
    private bool buildNavmesh = false;
    
    [SerializeField]
    private bool buildLightProbes = false;

	[SerializeField]
	private bool buildOcclusion = false;

	[SerializeField]
    private bool hasNavmesh = false;

    [SerializeField]
    private bool hasLightMaps = false;

    private DirectoryInfo[] levelsInMod;

    [SerializeField] 
    private bool showAdvancedExport = false;

    [SerializeField]
    private int currentLevelInModIndex = 0;
    
    /// <summary>
    /// Cached for creating new levels
    /// </summary>
    private readonly LevelDefinition newLevelDefinition = new LevelDefinition();
    
    public LevelKitTab_Build(LevelKitTool tool)
        : base(tool, TabAvailability.InLevel)
    {
    }

    public override void OnFocusGain()
    {
        if (m_Tool.isInLevelKitLevel)
        {
            UpdateLevelInformation();
        }
    }

    public override void OnSceneChange()
    {
        base.OnSceneChange();

        if (m_Tool.isInLevelKitLevel)
        {
            UpdateLevelInformation();
        }
    }
    
    private void UpdateLevelInformation()
    {
        DirectoryInfo modDirectoryInfo = new DirectoryInfo(m_Tool.fullModPath);
        FileInfo[] levelJsons = modDirectoryInfo.GetFiles("*level.json", SearchOption.AllDirectories);
        levelsInMod = new DirectoryInfo[levelJsons.Length];

        for (int i = 0; i < levelJsons.Length; i++)
        {
            levelsInMod[i] = levelJsons[i].Directory;
            if (levelsInMod[i].FullName.EndsWith(m_Tool.fullLevelPath))
            {
                currentLevelInModIndex = i;
            }
        }
    }
    
    public override void Draw()
    {
        string levelName = m_Tool.currentLevel.name;
        string scriptPath = string.Format("{0}/Content/{1}_mission.lua", m_Tool.fullLevelPath, levelName);

        hasNavmesh = File.Exists(m_Tool.fullSceneDirPath + "/" + levelName + "/NavMesh.asset");
        hasLightMaps = File.Exists(m_Tool.fullSceneDirPath + "/" + levelName + "/LightingData.asset");

        // Level Info
        DrawLevelInfo( m_Tool.fullLevelPath, scriptPath);

        // Build Settings
        EditorGUILayout.LabelField("Build Settings", EditorStyles.boldLabel);
        DrawBuildSettings();

        // Build Level
        DrawBuildControls( m_Tool.fullLevelPath);
        
    }

    private void DrawLevelInfo(string levelPath, string scriptPath)
    {
        // Build up list of levels in the mod to allow switching
        string[] levelArr = new string[levelsInMod.Length + 1];
        for (var i = 0; i < levelsInMod.Length; i++)
        {
            levelArr[i] = levelsInMod[i].Name;
        }

        // Add the option to create a new level
        int createNewLevelIndex = levelArr.Length - 1;
        levelArr[createNewLevelIndex] = "New...";
        
        int levelIndex = EditorGUILayout.Popup("Current Level", currentLevelInModIndex, levelArr);
        bool isCreateNewLevel = levelIndex == createNewLevelIndex;
        
        // If we're swtiching
        if (currentLevelInModIndex != levelIndex 
            && !isCreateNewLevel
            && currentLevelInModIndex != createNewLevelIndex)
        {
            // Switch levels
            // Find Scene
            FileInfo[] scenes = levelsInMod[levelIndex].GetFiles("*.unity", SearchOption.AllDirectories);
            if (scenes.Length > 0)
            {
                // Make sure we save dirty scenes first
                EditorSceneManager.SaveCurrentModifiedScenesIfUserWantsTo();
                
                // Open the first
                EditorSceneManager.OpenScene(scenes[0].FullName, OpenSceneMode.Single);
                
                // Bail early 
                return;
            }
        }
        // If we're creating a new level
        else if (isCreateNewLevel)
        {
            // Create new level
            ++EditorGUI.indentLevel;
            LevelKitUtils.DrawEditiableLevelDefinition(newLevelDefinition);
            --EditorGUI.indentLevel;
            if (GUILayout.Button("Create"))
            {
                LevelKitTab_CreateMod.CreateNewLevel(m_Tool.fullModPath, newLevelDefinition, true, false);
            }
        }
        // If we're displaying info about the current level
        else
        {
            ++EditorGUI.indentLevel;
            LevelKitUtils.DrawEditiableLevelDefinition(m_Tool.currentLevel);
            --EditorGUI.indentLevel;
        }
        currentLevelInModIndex = levelIndex;

        // Don't show these options if we're in the create new level context
        if (!isCreateNewLevel)
        {
            GUILayout.BeginHorizontal();

            if (GUILayout.Button("Save level info changes"))
            {
                m_Tool.SaveLevelJsonChanges();
            }
            if (GUILayout.Button("Open Level Folder") && Directory.Exists(levelPath))
            {
                EditorUtility.OpenWithDefaultApp(levelPath);
            }
            if (GUILayout.Button("Open Mission Script") && File.Exists(scriptPath))
            {
                Selection.activeObject = AssetDatabase.LoadMainAssetAtPath(scriptPath);
                EditorUtility.OpenWithDefaultApp(scriptPath);
            }
            GUILayout.EndHorizontal();
        }

        EditorGUILayout.Space();
    }

    private void DrawBuildSettings()
    {

		EditorGUILayout.HelpBox("Before baking or building the level, rember to mark all non-moving objects in your scene as static.\nAll building geometry (ground, walls, floors, etc) should be set to 'level' layer.\nMore detailed instructions about how to best set up your scene can be found in the wiki.", MessageType.Info, true);

		EditorGUILayout.BeginVertical("Box");

        // Nav Mesh
        {
            GUILayout.Label("Navigation Mesh", EditorStyles.boldLabel);
            GUILayout.BeginHorizontal();
            EditorGUI.indentLevel++;
            buildNavmesh = EditorGUILayout.Toggle("On Build", buildNavmesh);

            if (NavMeshBuilder.isRunning)
            {
                if (GUILayout.Button("Cancel"))
                {
                    NavMeshBuilder.Cancel();
                }
            }
            else
            {
                if (GUILayout.Button("Bake Now"))
                {
                    NavMeshBuilder.BuildNavMeshAsync();
                }
            }
            EditorGUI.indentLevel--;
            GUILayout.EndHorizontal();
        }
        
        // Light probes
        {
            GUILayout.Label("Light Probes", EditorStyles.boldLabel);
            GUILayout.BeginHorizontal();
            
            GUI.enabled = hasNavmesh;
            buildLightProbes = EditorGUILayout.Toggle("On Build", buildLightProbes);

            if (GUILayout.Button("Bake Now"))
            {
                LightProbePlacement.PlaceProbes();
            }
            
            GUILayout.EndHorizontal();

            GUI.enabled = true;
        }

		// Light maps
		{
			GUILayout.Label("Lightmaps", EditorStyles.boldLabel);

			if (Lightmapping.giWorkflowMode == Lightmapping.GIWorkflowMode.OnDemand) {
				EditorGUI.indentLevel++;

				if (Lightmapping.isRunning) {
					GUILayout.BeginHorizontal();
					{
						buildLightMaps = EditorGUILayout.Toggle("On Build", buildLightMaps);

						Rect rect = GUILayoutUtility.GetRect(20, 20, "TextField");
						EditorGUI.ProgressBar(rect, Lightmapping.buildProgress,
							string.Format("({0:P})", Lightmapping.buildProgress));

						if (GUILayout.Button("Cancel")) {
							Lightmapping.Cancel();
						}
					}
					GUILayout.EndHorizontal();

				}
				else {
					GUILayout.BeginHorizontal();
					{
						buildLightMaps = EditorGUILayout.Toggle("On Build", buildLightMaps);

						if (GUILayout.Button("Bake Automatically")) {
							Lightmapping.giWorkflowMode = Lightmapping.GIWorkflowMode.Iterative;
						}
						if (GUILayout.Button("Bake Now")) {
							Lightmapping.BakeAsync();
						}
					}
					GUILayout.EndHorizontal();

				}
				EditorGUI.indentLevel--;
			}
			else {
				buildLightMaps = false;

				if (GUILayout.Button("Bake On Demand")) {
					Lightmapping.giWorkflowMode = Lightmapping.GIWorkflowMode.OnDemand;
				}

				if (Lightmapping.isRunning) {
					Rect rect = GUILayoutUtility.GetRect(18, 18, "TextField");
					EditorGUI.ProgressBar(rect, Lightmapping.buildProgress, string.Format("({0:P})", Lightmapping.buildProgress));
				}
			}
		}

		// Occlusion Culling
		{
			GUILayout.Label("Occlusion Culling", EditorStyles.boldLabel);
			GUILayout.BeginHorizontal();
			EditorGUI.indentLevel++;
			buildOcclusion = EditorGUILayout.Toggle("On Build", buildOcclusion);

			if (StaticOcclusionCulling.isRunning) {
				if (GUILayout.Button("Cancel")) {
					StaticOcclusionCulling.Cancel();
				}
			}
			else {
				if (GUILayout.Button("Bake Now")) {
					StaticOcclusionCulling.GenerateInBackground();
				}
			}
			EditorGUI.indentLevel--;
			GUILayout.EndHorizontal();
		}

		EditorGUILayout.EndVertical();
    }
    
    private void DrawBuildControls(string levelPath)
    {
        string editorBusyReason;
        bool isEditorBusy = LevelKitUtils.IsEditorBusy(out editorBusyReason);
        GUI.enabled = !isEditorBusy;

        showAdvancedExport = EditorGUILayout.Foldout(showAdvancedExport, "Advanced Export...");
        if (showAdvancedExport)
        {
            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("Export Mod as Unity Package"))
            {
                string path =
                    EditorUtility.OpenFolderPanel("Choose package location", Application.dataPath, string.Empty);

                if (!string.IsNullOrEmpty(path)
                    && Directory.Exists(path))
                {
                    AssetDatabase.ExportPackage(m_Tool.fullModPath, Path.Combine(path, "Mod.unitypackage"),
                        ExportPackageOptions.IncludeDependencies
                        | ExportPackageOptions.Recurse
                        | ExportPackageOptions.Interactive);
                }
            }

            if (GUILayout.Button(LevelKitUtils.TempGUIContent("Export Mod to folder", 
                "This is helpful for distributing your mod to other sources")))
            {
                string modOutputPath = EditorUtility.OpenFolderPanel("Select path for export", 
                    Environment.GetFolderPath(Environment.SpecialFolder.Desktop), 
                    string.Empty);

                if (Directory.Exists(modOutputPath))
                {
                    string finalPath = Path.Combine(modOutputPath,
                        string.Format("{0} - {1:yyyy-MM-dd - H.mm}", Path.GetFileName(m_Tool.fullModPath), DateTime.Now));
                    
                    // Copy over mod folder to temp directory, remove the scene folder and meta files
                    LevelKitUtils.CopyDirectory(m_Tool.fullModPath,
                        finalPath,
                        file => file.Extension != ".meta",
                        directory => directory.Name != "Scene");
                        
                    LevelKitUtils.RemoveReadonly(finalPath, true);
                    
                    EditorUtility.OpenWithDefaultApp(finalPath);
                }
            }

            EditorGUILayout.EndHorizontal();
        }

        string buildLevelString;
        if (isEditorBusy)
        {
            buildLevelString = editorBusyReason;
        }
        else
        {
            buildLevelString = string.Format("Build Level {0}", m_Tool.activeScene.isDirty
                ? "(Changes Detected)"
                : string.Empty);
        }

        if (GUILayout.Button(buildLevelString))
        {
            if (buildLightMaps)
            {
                Lightmapping.Bake();
            }
            
            // Make sure we have a nav mesh
            if (buildNavmesh || !hasNavmesh)
            {
                NavMeshBuilder.BuildNavMesh();
            }

            if (buildLightProbes)
            {
                LightProbePlacement.PlaceProbes();
            }

			// bake occlusion data
			if (buildOcclusion) {
				StaticOcclusionCulling.Compute();
			}

			string bundlePath = levelPath + "/Bundles";

            if (!Directory.Exists(bundlePath))
            {
                Directory.CreateDirectory(bundlePath);
            }
  

            if (LevelKitTab_Validate.Validate())
            {
                AssetImporter importer = AssetImporter.GetAtPath(SceneManager.GetActiveScene().path);
                importer.assetBundleName = SceneManager.GetActiveScene().name;

                //const BuildAssetBundleOptions options = BuildAssetBundleOptions.ForceRebuildAssetBundle 
                //                                        | BuildAssetBundleOptions.ChunkBasedCompression;
				const BuildAssetBundleOptions options = BuildAssetBundleOptions.ChunkBasedCompression;

				BuildPipeline.BuildAssetBundles(bundlePath, options, BuildTarget.StandaloneWindows);
                

				// Remove all other stuff, only keep the actual scene bundle:
                var filesToDelete = Directory.GetFiles(bundlePath).Where(p =>
                {
                    string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(p);
                    return fileNameWithoutExtension != null && !fileNameWithoutExtension.StartsWith(importer.assetBundleName);
                });
                foreach (var file in filesToDelete)
                {
                    try
                    {
                        File.Delete(file);
                    }
                    catch (Exception e)
                    {
                        UnityEngine.Debug.LogErrorFormat("Exception triggered during Build (File.Delete). '{0}'", e.Message);
                    }
                }

                importer.assetBundleName = string.Empty;

                EditorSceneManager.SaveScene(m_Tool.activeScene);
            }
            else
            {
                EditorApplication.Beep();
                if (EditorUtility.DisplayDialog(
                    "There are issues with your level",
                    "Please check the validation window",
                    "Ok"))
                {
                    m_Tool.currentTabType = LevelKitTool.TabType.Validate;
                }
            }
        }

        GUI.enabled = true;
    }

}

#endif // LEVEL_KIT && UNITY_EDITOR
