// Copyright Semaeopus Ltd. 2017
// This code was created as part of LevelKit on: 2019-11-26 - 9:25
// DO NOT EDIT THIS FILE - Code changes will NOT be picked up and may break your project
// Visit http://wiki.offgridthegame.com for help - Happy Hacking!

using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

/// <summary>
/// Wrapper around a system dictionary, but with the added bonus of being serialisable by Unity
/// Warning: This class will only serialise correctly if TKey and TValue are serialisable in their own right (So please check!)
/// </summary>
/// <typeparam name="TKey"></typeparam>
/// <typeparam name="TValue"></typeparam>
[System.Serializable]
public class SerialisableDictionary<TKey, TValue> : ISerializationCallbackReceiver, IEnumerable
{

	/// <summary>
	/// Our internal dictionary which we wrap around
	/// </summary>
	private Dictionary<TKey, TValue> internalDict;

	/// <summary>
	/// Init with custom capacity
	/// </summary>
	/// <param name="capacity"></param>
	protected SerialisableDictionary(int capacity)
	{
		internalDict = new Dictionary<TKey, TValue>(capacity);
	}

	/// <summary>
	/// Init with default capacity of 16
	/// </summary>
	protected SerialisableDictionary()
	: this(16)
	{
	}

    public SerialisableDictionary(SerialisableDictionary<TKey, TValue> other)
    {
        internalDict = InternalDictionary.ToDictionary(item => item.Key, item => item.Value);
    }

    /// <summary>
    /// The array holding our keys
    /// Key and values are seperate arrays so they can be differing types
    /// </summary>
    [SerializeField]
	private TKey[] keyArray;

	/// <summary>
	/// The array holding our value
	/// Key and values are seperate arrays so they can be differing types
	/// </summary>
	[SerializeField]
	private TValue[] valueArray;

	/// <summary>
	/// Get the number of KeyValue pairs
	/// </summary>
	public int Count { get { return internalDict.Count; } }

	/// <summary>
	/// Does the dictionary contain the passed in key?
	/// </summary>
	/// <param name="key"></param>
	/// <returns></returns>
	public bool ContainsKey(TKey key)
	{
		return internalDict.ContainsKey(key);
	}

	/// <summary>
	/// Attempt to get a value from the dictionary
	/// </summary>
	/// <param name="key"></param>
	/// <param name="value"></param>
	/// <returns></returns>
	public bool TryGetValue(TKey key, out TValue value)
	{
		return internalDict.TryGetValue(key, out value);
	}

	/// <summary>
	/// Remove a key value pair from the dictionary
	/// </summary>
	/// <param name="key"></param>
	public void Remove(TKey key)
	{
		internalDict.Remove(key);
	}

	/// <summary>
	/// Adds a key value pair to the dictionary
	/// </summary>
	/// <param name="key"></param>
	/// <param name="value"></param>
	public void Add(TKey key, TValue value)
	{
		internalDict.Add(key, value);
	}

	/// <summary>
	/// Get and set our reference to the internal dictionary,
	/// Sometimes needed for things like allowing MoonSharp to make Dynvalues from the dictionary
	/// </summary>
	public Dictionary<TKey, TValue> InternalDictionary
	{
		get { return internalDict; }
		set { internalDict = value; }
	}

	/// <summary>
	/// Set up our Key/Value arrays before we Serialise
	/// </summary>
	public void OnBeforeSerialize()
	{
		int dictSize = internalDict.Count;
		if (dictSize > 0)
		{
			keyArray = new TKey[dictSize];
			valueArray = new TValue[dictSize];

			int count = 0;
			foreach (var pair in internalDict)
			{
				keyArray[count] = pair.Key;
				valueArray[count] = pair.Value;

				++count;
			}
		}
	}

	/// <summary>
	/// Initialise our dictionary from the Key/Value arrays
	/// </summary>
	public void OnAfterDeserialize()
	{
		if (keyArray.Length != 0 &&
		    valueArray.Length != 0 &&
		    keyArray.Length == valueArray.Length &&
		    internalDict != null)
		{
			internalDict.Clear();
			int size = keyArray.Length;

			for (int i = 0; i < size; ++i)
			{
				internalDict[keyArray[i]] = valueArray[i];
			}
		}
	}

	/// <summary>
	/// Allow iteration in foreach loops
	/// </summary>
	public IEnumerator GetEnumerator()
	{
		return internalDict.GetEnumerator();
	}

	/// <summary>
	/// Indexer for getting and setting elements like you would a normal array
	/// </summary>
	/// <param name="key"></param>
	public TValue this[TKey key]
	{
		get { return internalDict[key]; }
		set { internalDict[key] = value; }
	}
}

[System.Serializable]
public class StringStringDict : SerialisableDictionary<string, string> { }
[System.Serializable]
public class StringDoubleDict : SerialisableDictionary<string, double> { }
[System.Serializable]
public class StringBoolDict : SerialisableDictionary<string, bool> { }
