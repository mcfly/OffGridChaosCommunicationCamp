// Copyright Semaeopus Ltd. 2017
// This code was created as part of LevelKit on: 2019-11-26 - 9:25
// DO NOT EDIT THIS FILE - Code changes will NOT be picked up and may break your project
// Visit http://wiki.offgridthegame.com for help - Happy Hacking!

//#if UNITY_EDITOR

using System.Collections.Generic;
using UnityEngine;

#if UNITY_EDITOR
using UnityEditor;
#endif

using System;
using System.Reflection;
using System.IO;

[System.Serializable]
public class SingularPlayerPath
{
    public string _name;
    public Color _lineColorStart;
    public Color _lineColorEnd;
    public List<Vector3> _points;
    public List<string> _pointsText;
    public List<int> _pointIndexUI; // Index of the points that are selected in the editor scene window //
    public int _firstVisiblePointID = -1;
    public int _lastVisiblePointID = -1;
    public int _toAddHelper;


    public SingularPlayerPath(string name, Color lineColorStart, Color lineColorEnd, int toAddHelper)
    {
        _name = name;
        _lineColorStart = lineColorStart;
        _lineColorEnd = lineColorEnd;
        _points = new List<Vector3>();
        _pointsText = new List<string>();
        _pointIndexUI = new List<int>();
        _toAddHelper = toAddHelper;
    }

    public void AddPoint(Vector3 newPoint, int index = -1)
    {
        index = index == -1 ? _points.Count : index; // For default insert a new point at the end of the path // 

        _points.Insert(index, newPoint);
        _pointsText.Insert(index, "");

        _pointIndexUI.Clear();
        _pointIndexUI.Add(index);
    }


    public void RemoveSelectedPoints()
    {
        List<int> aux = new List<int>();
        for (int i = 0; i < _points.Count; i++)
        {
            aux.Add(i);
        }

        for (int i = 0; i < _pointIndexUI.Count; i++)
        {
            aux[_pointIndexUI[i]] = -1;
        }

        List<Vector3> pointsAux = new List<Vector3>();
        List<string> pointsTextAux = new List<string>();

        for (int i = 0; i < aux.Count; i++)
        {
            if (aux[i] != -1)
            {
                pointsAux.Add(_points[i]);
                pointsTextAux.Add(_pointsText[i]);
            }
        }

        _points = new List<Vector3>(pointsAux);
        _pointsText = new List<string>(pointsTextAux);

        _pointIndexUI.Clear();
    }

    public bool PointSelected(int index)
    {
        for (int i = 0; i < _pointIndexUI.Count; i++)
        {
            if (_pointIndexUI[i] == index)
            { return true; }
        }

        return false;
    }

    public bool GetSelectedPoint(int orderWanted, out int index)
    {
        if (_pointIndexUI != null && _pointIndexUI.Count > orderWanted)
        {
            index = _pointIndexUI[orderWanted];
            return true;
        }

        index = -1;
        return false;
    }
}

[System.Serializable]
[ExecuteInEditMode]
public class PlayerPath : MonoBehaviour
{
    public bool _enabled = true;
    private bool _lastEnabled = true;
    public bool _allPathIsVisible = false;
    public float _visibleDistance = 15;
    public bool _allPointsVisible = true;
    public enum PathMode { Default, UIOnlyOnSelectedPath, UIDisabled, AddPointsDisabled, Disabled }; // Broken //
    [HideInInspector] public PathMode _pathMode; // Is only being used PathMode.Default //
    public Color _defaultPathColorStart = Color.green;
    public Color _defaultPathColorEnd = Color.red;
    private Material _lineRendererMaterial;
    public List<SingularPlayerPath> _paths = new List<SingularPlayerPath>();
    public GUIStyle _defaultGUIStyle;
    [HideInInspector] public int _pathSelected;
#if UNITY_EDITOR
    private Action<SceneView> _sceneViewFunc;
#endif
    private bool _gameObjectSelected = false;
    [HideInInspector] public float _buttonSize = 0.15f;
    [HideInInspector] public List<LineRenderer> _lineRenderers = new List<LineRenderer>();
    [HideInInspector] public int _firstPointID = -1;
    [HideInInspector] public int _lastPointID = -1;
    private bool _outlineLastState;
    private List<GradientAlphaKey> _gradientAlphaKeysList = new List<GradientAlphaKey>();
    private Camera _cameraAux;
    private int _helperIDToAdd = 0;
    private LineRenderer[] _childLineRenderers;

    private void OnEnable()
    {
        transform.gameObject.tag = "EditorOnly";

        if (_defaultGUIStyle == null)
        {
            _defaultGUIStyle = "box";
            _defaultGUIStyle.font = Resources.GetBuiltinResource<Font>("Arial.ttf");
            _defaultGUIStyle.normal.textColor = Color.black;
        }

#if UNITY_EDITOR
        if (_sceneViewFunc == null)
        {
            _sceneViewFunc = new Action<SceneView>(BackgroundUpdate);
            SceneView.duringSceneGui += _sceneViewFunc;
        }
#endif

        if (Application.isPlaying)
        {
            EnablePlayerPath(false);
        }
    }

#if UNITY_EDITOR
    private void OnDisable()
    {
        SceneView.duringSceneGui -= _sceneViewFunc;
        _sceneViewFunc = null;
    }
#endif

    private void Update()
    {
        if(Application.isPlaying)
        {
            CustomUpdate();
        }
    }

#if UNITY_EDITOR
    /// <summary>
    /// This method is always running
    /// </summary>
    /// <param name="sceneview"></param>
    private void BackgroundUpdate(SceneView sceneview)
    {
        //if (!Application.isPlaying)
        {
            CustomUpdate(sceneview);
        }
    }
#endif

    private void CustomUpdate(
#if UNITY_EDITOR
        SceneView sceneView = null
#endif
        )
    {

#if UNITY_EDITOR
        /** Safe check ! **/
        if (this == null || gameObject == null)
        {
            _sceneViewFunc = null;
            DestroyImmediate(this);
        }
#endif

        /** Enable / Disable code **/
        if (_enabled != _lastEnabled)
        {
            EnablePlayerPath(_enabled);
        }

        _lastEnabled = _enabled;

        /** Show player path data **/
        if (_enabled)
        {
            transform.eulerAngles = new Vector3(90, 0, 0);
            int pathID = 0;

            /** Draw path(s) and show text points **/
            foreach (SingularPlayerPath path in _paths)
            {
                //Handles.color = path._lineColorStart;
                //Handles.DrawPolyLine(path._points.ToArray());

                /** Search/Update line renderers **/
                _lineRenderers.Clear();

                foreach (Transform child in transform)
                {
                    _lineRenderers.Add(child.GetComponent<LineRenderer>());
                }

                if ((_lineRenderers.Count - 1) < pathID)
                {
                    CreateLineRenderer(pathID);

                }

                LineRenderer pathLine = _lineRenderers[pathID];
                pathLine.useWorldSpace = true;
                pathLine.alignment = LineAlignment.TransformZ;


                if (!_allPathIsVisible) // Only show path near the scene camera //
                {
#if UNITY_EDITOR
                    if (!Application.isPlaying)
                    {
                        _cameraAux = SceneView.currentDrawingSceneView.camera;
                    }
                    else
#endif
                    {
                        _cameraAux = Camera.main;
                    }


                    Vector3 sceneCameraPos = _cameraAux.transform.position;

                    _firstPointID = -1;
                    _lastPointID = -1;
                    float percentageBegin = 0;
                    float percentageEnd = 1;

                    float closestDistance = Mathf.Infinity;
                    int closestPoint = -1;
                    for (int i = 0; i < path._points.Count; i++)
                    {
                        /** Only check the closest points visible in the scene camera **/
                        Vector3 screenPoint = _cameraAux.WorldToViewportPoint(path._points[i]);
                        bool onScreen = screenPoint.z > 0 && screenPoint.x > 0 && screenPoint.x < 1 && screenPoint.y > 0 && screenPoint.y < 1;

                        if (onScreen) // Only check points that are visible in the camera //
                        {
                            Vector3 diff = path._points[i] - sceneCameraPos;
                            float distance = diff.magnitude;

                            if (distance < _visibleDistance)
                            {
                                if (distance < closestDistance)
                                {
                                    closestDistance = distance;
                                    closestPoint = i;
                                }
                            }
                        }
                    }

                    // If doesn't not exist a closest point then the path isn't shown //
                    if (closestPoint != -1)
                    {
                        _firstPointID = closestPoint;
                        _lastPointID = closestPoint;

                        /** Search for the path first point **/
                        for (int i = (closestPoint + 1); i < path._points.Count; i++)
                        {
                            Vector3 diff = path._points[i] - sceneCameraPos;
                            float distance = diff.magnitude;

                            if (distance < _visibleDistance)
                            {
                                _lastPointID = i;
                            }

                            else
                            {
                                if (_lastPointID + 1 != i)
                                {
                                    break;
                                }
                            }
                        }

                        /** Search for the path last point **/
                        for (int i = (closestPoint - 1); i >= 0; i--)
                        {
                            Vector3 diff = path._points[i] - sceneCameraPos;
                            float distance = diff.magnitude;

                            if (distance < _visibleDistance)
                            {
                                _firstPointID = i;
                            }

                            else
                            {
                                if (_firstPointID - 1 != i)
                                {
                                    break;
                                }
                            }
                        }

                        /** Calculate the first and last point percentage in the path **/
                        if (_firstPointID != -1 && _firstPointID < (path._points.Count) - 1)
                        {
                            percentageBegin = GetPathPercentage(path, _firstPointID, sceneCameraPos);
                        }

                        if (_lastPointID != -1 && _lastPointID < (path._points.Count) - 1)
                        {
                            percentageEnd = GetPathPercentage(path, _lastPointID, sceneCameraPos);
                        }
                    }


                    if (_firstPointID != -1 && _firstPointID != _lastPointID)
                    {
                        /** Set path points **/
                        pathLine.positionCount = path._points.Count;
                        pathLine.SetPositions(path._points.ToArray());

                        /** Set path gradient alpha keys **/
                        _gradientAlphaKeysList.Clear();

                        if (_firstPointID != 0)
                        {
                            _gradientAlphaKeysList.Add(new GradientAlphaKey(0.0f, percentageBegin));
                        }

                        _gradientAlphaKeysList.Add(new GradientAlphaKey(1.0f, (percentageBegin + percentageEnd) * 0.5f));

                        if (_lastPointID != (path._points.Count - 1))
                        {
                            _gradientAlphaKeysList.Add(new GradientAlphaKey(0.0f, percentageEnd));
                        }

                        /** Set path gradient **/
                        Gradient gradient = new Gradient();
                        gradient.SetKeys(
                            new GradientColorKey[] { new GradientColorKey(path._lineColorStart, 0.0f), new GradientColorKey(path._lineColorEnd, 0.5f) },
                            _gradientAlphaKeysList.ToArray()
                        );

                        pathLine.colorGradient = gradient;
                    }

                    else // Path isn't shown //
                    {
                        pathLine.positionCount = 0;
                    }
                }

                else // Show all the paths //
                {
                    _firstPointID = 0;
                    _lastPointID = path._points.Count - 1;

                    pathLine.positionCount = path._points.Count;
                    pathLine.SetPositions(path._points.ToArray());

                    Gradient gradient = new Gradient();
                    gradient.SetKeys(
                        new GradientColorKey[] { new GradientColorKey(path._lineColorStart, 0.0f), new GradientColorKey(path._lineColorEnd, 0.5f) },
                        new GradientAlphaKey[] { new GradientAlphaKey(1.0f, 0) }
                    );

                    pathLine.colorGradient = gradient;
                }

#if UNITY_EDITOR
                /** Show path texts **/
                for (int i = 0; i < path._pointsText.Count; i++)
                {
                    string pointText = path._pointsText[i];
                    if (pointText != null && pointText != "" && sceneView != null)
                    {
                        Handles.Label(path._points[i] + Camera.current.transform.right * 0.5f + Camera.current.transform.up * 0.5f,
                            pointText, _defaultGUIStyle);
                    }


                    if (_gameObjectSelected && sceneView != null)
                    {
                        bool isPointSelected = path.PointSelected(i) ? true : false;

                        if (isPointSelected) // Show label handle above the selected point if is selected //
                        {
                            Color styleColorBefore = EditorStyles.boldLabel.normal.textColor;
                            int styleSizeBefore = EditorStyles.boldLabel.fontSize;

                            GUIStyle labelStyle = EditorStyles.boldLabel;
                            labelStyle.normal.textColor = new Color(1, 0.549f, 0, 1); // Dark Orange color //
                            labelStyle.fontSize = 20;

                            Handles.Label(path._points[i] + Camera.current.transform.right * -0.5f + Camera.current.transform.up * 0.5f,
                                    i.ToString(), labelStyle);

                            labelStyle.normal.textColor = styleColorBefore;
                            labelStyle.fontSize = styleSizeBefore;
                        }
                    }
                }

                /** Show buttons but without any functionality  **/
                if (!_gameObjectSelected && !Application.isPlaying)
                {
                    int j = 0;

                    if (_pathMode != PathMode.UIOnlyOnSelectedPath ||
                           (_pathMode == PathMode.UIOnlyOnSelectedPath && j == _pathSelected))
                    {

                        for (int i = 0; i < path._points.Count; i++)
                        {

                            Handles.color = Color.blue;
                            Vector3 buttonPosition = path._points[i];

                            if (_allPointsVisible || (i >= _firstPointID && i <= _lastPointID))
                            {
                                if (Handles.Button(buttonPosition, Quaternion.LookRotation(Camera.current.transform.forward, Camera.current.transform.up),
                                    _buttonSize, _buttonSize, Handles.DotHandleCap))
                                {
                                    // Do nothing !!!
                                }
                            }

                        }
                    }
                }

                if (_gameObjectSelected)
                {
                    Tools.hidden = true;
                }


                SceneView.RepaintAll();
#endif
                //HandleUtility.Repaint();

                path._firstVisiblePointID = _firstPointID;
                path._lastVisiblePointID = _lastPointID;

                pathID++;
            }

#if UNITY_EDITOR
            /** Check if the gameobject is selected **/
            GameObject gameObjectSelected = Selection.activeGameObject;
            if (!_gameObjectSelected)
            {
                if (gameObjectSelected == gameObject) // This game object was selected //
                {
                    _gameObjectSelected = true;
                    Selected();
                }
            }

            else
            {
                if (gameObjectSelected != gameObject) // This game object was unselected //
                {
                    _gameObjectSelected = false;
                    Unselected();
                }
            }
#endif

            CheckMaterialOnLineRenderers();
        }

        /** Add a new path if non exist **/
        if(_paths.Count == 0)
        {
            AddPath();
        }
    }

    public void EnablePlayerPath(bool value)
    {
        _enabled = value;

        foreach (Transform child in transform)
        {
            child.gameObject.SetActive(value);
        }
    }

#if UNITY_EDITOR
    private void Selected()
    {
        Tools.hidden = true;
        SelectionOutline(false);
    }

    private void Unselected()
    {
        Tools.hidden = false;
        SceneView.RepaintAll();
        SelectionOutline(_outlineLastState);
    }
#endif

    public string[] GetPathsName()
    {
        string[] toReturn = new string[_paths.Count];

        for (int i = 0; i < _paths.Count; i++)
        {
            toReturn[i] = _paths[i]._name;
        }

        return toReturn;
    }

    private static float InverseLerp(Vector3 a, Vector3 b, Vector3 value)
    {
        Vector3 AB = b - a;
        Vector3 AV = value - a;
        return Vector3.Dot(AV, AB) / Vector3.Dot(AB, AB);
    }

    private float GetPathPercentage(SingularPlayerPath path, int pathPointID, Vector3 sceneCameraPos)
    {
        Vector3 pathPointAux = path._points[pathPointID + 1];
        float camDistance = (pathPointAux - sceneCameraPos).magnitude;
        float distanceAux = camDistance - _visibleDistance;

        Vector3 sectionDir = (path._points[pathPointID + 1] - path._points[pathPointID]).normalized;
        Vector3 lastVisiblePos = path._points[pathPointID] + (sectionDir * distanceAux);

        float sectionPercentage = InverseLerp(path._points[pathPointID], pathPointAux, lastVisiblePos);
        float percentageRatioAux = 1f / (float)path._points.Count;
        float percentageToReturn = (percentageRatioAux * sectionPercentage) + (percentageRatioAux * (pathPointID));
        return percentageToReturn;
    }

#if UNITY_EDITOR
    /// <summary>
    /// Enable or disable the scene window object selection outline
    /// </summary>
    /// <param name="isEnable"></param>
    private void SelectionOutline(bool isEnable)
    {
        var asm = Assembly.GetAssembly(typeof(Editor));
        var type = asm.GetType("UnityEditor.AnnotationUtility");

        if (type == null)
        {
            return;
        }

        var setSelectionOutline = type.GetProperty("showSelectionOutline", BindingFlags.Static | BindingFlags.NonPublic);

        if (setSelectionOutline == null)
            return;

        if (!isEnable)
        {
            _outlineLastState = (bool)setSelectionOutline.GetValue(null);
        }

        setSelectionOutline.SetValue(null, isEnable, null);
    }
#endif

    public void CreateLineRenderer(int pathID)
    {
        GameObject newLineObj = new GameObject();
        newLineObj.transform.SetParent(transform);
        newLineObj.transform.localPosition = Vector3.zero;
        newLineObj.transform.localEulerAngles = Vector3.zero;
        newLineObj.name = "PlayerPath_" + pathID;

        LineRenderer newLineRenderer = newLineObj.AddComponent<LineRenderer>();
        _lineRendererMaterial = _lineRendererMaterial == null ? new Material(Shader.Find("Custom/AlwaysOnTop")) : _lineRendererMaterial;

        newLineRenderer.material = _lineRendererMaterial;
        newLineRenderer.startWidth = 0.25f;
        newLineRenderer.endWidth = 0.25f;

        _lineRenderers.Add(newLineRenderer);
    }

    private void CheckMaterialOnLineRenderers()
    {
        _childLineRenderers = GetComponentsInChildren<LineRenderer>();
        _lineRendererMaterial = _lineRendererMaterial == null ? new Material(Shader.Find("Custom/AlwaysOnTop")) : _lineRendererMaterial;

        foreach (LineRenderer lineRenderer in _childLineRenderers)
        {
            lineRenderer.material = _lineRendererMaterial;
        }
    }

    public void AddPath()
    {
        SingularPlayerPath newPath = new SingularPlayerPath("Path " + _helperIDToAdd, _defaultPathColorStart, _defaultPathColorEnd, _helperIDToAdd);
        _paths.Add(newPath);
        _pathSelected = _paths.Count - 1;
        _helperIDToAdd++;
    }

    public void RemovePath()
    {
        if(_pathSelected == _paths.Count - 1) // If the removed path is the last element then the next path added will have the same ID //
        {
            _helperIDToAdd--; 
        }

        _paths.RemoveAt(_pathSelected);
        _pathSelected = (_pathSelected - 1) < 0 ? 0 : --_pathSelected;
        DestroyImmediate(_lineRenderers[_lineRenderers.Count - 1].gameObject);
        _lineRenderers.RemoveAt(_lineRenderers.Count - 1);

        if(_paths.Count == 0) // Reset points ID if don't exist any path //
        {
            _helperIDToAdd = 0;
        }
    }
}
#if UNITY_EDITOR

[CustomEditor(typeof(PlayerPath))]
class PlayerPathEditor : Editor
{
    PlayerPath _target;
    private PlayerPath Target
    {
        get
        {
            if (_target == null)
            {
                _target = target as PlayerPath;
            }

            return _target;
        }
    }

    private bool _multipleKeyPressed;
    private KeyCode _multiplePointKey = KeyCode.Space;

    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        /** Options **/
        EditorGUILayout.Space();
        EditorGUILayout.Space();
        EditorGUILayout.TextField("Options", EditorStyles.boldLabel);

        if (GUILayout.Button("Add new path"))
        {
            Target.AddPath();
        }

        /** Select path **/
        EditorGUILayout.Space();
        EditorGUILayout.Space();
        EditorGUILayout.TextField("Selected path", EditorStyles.boldLabel);

        EditorGUILayout.BeginHorizontal();

        int pathSelected = EditorGUILayout.Popup(Target._pathSelected, Target.GetPathsName());
        if (pathSelected != Target._pathSelected) { SceneView.RepaintAll(); }
        Target._pathSelected = pathSelected;

        if (GUILayout.Button("Remove path", GUILayout.MaxWidth(100)))
        {
            Target.RemovePath();
        }
        EditorGUILayout.EndHorizontal();

        /** Path information **/
        if (Target._paths != null && Target._paths.Count > 0 && Target._pathSelected < Target._paths.Count)
        {
            string pathName = EditorGUILayout.TextField("Name", Target._paths[Target._pathSelected]._name);
            if (pathName != "") { Target._paths[Target._pathSelected]._name = pathName; }

            Target._paths[Target._pathSelected]._lineColorStart = EditorGUILayout.ColorField("Color", Target._paths[Target._pathSelected]._lineColorStart);
            Target._paths[Target._pathSelected]._lineColorEnd = EditorGUILayout.ColorField("Color", Target._paths[Target._pathSelected]._lineColorEnd);

            for (int i = 0; i < Target._paths[Target._pathSelected]._pointsText.Count; i++)
            {
                bool isPointSelected = Target._paths[Target._pathSelected].PointSelected(i) ? true : false;

                EditorGUILayout.BeginHorizontal();

                if (isPointSelected) // Change label field in the selected point //
                {
                    Color styleColorBefore = EditorStyles.boldLabel.normal.textColor;
                    GUIStyle labelStyle = EditorStyles.boldLabel;
                    labelStyle.normal.textColor = Color.yellow;
                    EditorGUILayout.LabelField("Text Point " + i, labelStyle);
                    labelStyle.normal.textColor = styleColorBefore;

                }
                else { EditorGUILayout.LabelField("Text Point " + i); }

                Target._paths[Target._pathSelected]._pointsText[i] = EditorGUILayout.TextField(/*"Text Point " + i,*/ Target._paths[Target._pathSelected]._pointsText[i]);
                EditorGUILayout.EndHorizontal();
            }
        }
    }

    void OnSceneGUI()
    {
        bool multipleKeyPressedAux = _multipleKeyPressed;
        if (SelectMultiplePointsKeyPressed(out multipleKeyPressedAux))
        {
            _multipleKeyPressed = multipleKeyPressedAux;
        }

        Vector3 buttonPosition;
        float buttonSize = Target._buttonSize;

        EditorGUI.BeginChangeCheck();

        /** Points handle position, remove button and text label **/
        if (Target._enabled && Target._pathMode != PlayerPath.PathMode.Disabled && Target._pathMode != PlayerPath.PathMode.UIDisabled)
        {
            int j = 0;

            foreach (SingularPlayerPath path in Target._paths)
            {
                if (Target._pathMode != PlayerPath.PathMode.UIOnlyOnSelectedPath ||
                    (Target._pathMode == PlayerPath.PathMode.UIOnlyOnSelectedPath && j == Target._pathSelected))
                {
                    for (int i = 0; i < path._points.Count; i++)
                    {
                        /** Handles position **/
                        if (path.PointSelected(i))
                        {
                            Vector3 newTargetPosition = Handles.PositionHandle(path._points[i], Quaternion.identity);
                            Vector3 moveDiff = newTargetPosition - path._points[i];
                            path._points[i] = newTargetPosition;

                            // Move multiple points //
                            for (int z = 0; z < path._points.Count; z++)
                            {
                                if (path.PointSelected(z))
                                {
                                    if (z != i)
                                    {
                                        path._points[z] += moveDiff;
                                    }
                                }
                            }
                        }

                        /** Points main button **/
                        if (!path.PointSelected(i))
                        {
                            Handles.color = Color.blue;
                            buttonPosition = path._points[i];

                            if (Target._allPointsVisible || (i >= path._firstVisiblePointID && i <= path._lastVisiblePointID))
                            {
                                if (Handles.Button(buttonPosition, Quaternion.LookRotation(Camera.current.transform.forward, Camera.current.transform.up),
                                buttonSize, buttonSize, Handles.DotHandleCap))
                                {
                                    if (_multipleKeyPressed) // Select multiple points //
                                    {
                                        path._pointIndexUI.Add(i);
                                    }

                                    else // Only one point selected //
                                    {
                                        path._pointIndexUI.Clear();
                                        path._pointIndexUI.Add(i);

                                    }

                                    return;
                                }
                            }
                        }

                        /** Delete points **/
                        if (path.PointSelected(i))
                        {
                            // Remove Button //
                            Handles.color = Color.red;
                            buttonPosition = path._points[i] + Camera.current.transform.right * 0.5f;

                            if (Handles.Button(buttonPosition, Quaternion.LookRotation(Camera.current.transform.forward, Camera.current.transform.up),
                                buttonSize, buttonSize, Handles.DotHandleCap))
                            {
                                path.RemoveSelectedPoints(); // Remove all the selected points //

                                Undo.RegisterCompleteObjectUndo(Target, "PlayerPath changed");
                                EditorUtility.SetDirty(Target);

                                return;
                            }
                        }
                    }


                    // Add middle point button //
                    int indexWanted = -1;
                    if (path.GetSelectedPoint(0, out indexWanted)) // Only show the button on a point, for default the first point is selected (if it exist) //
                    {
                        // If the first point selected is the final of the path then select the second point if it exist //
                        if (indexWanted == path._points.Count - 1) { path.GetSelectedPoint(1, out indexWanted); }

                        if (indexWanted != -1)
                        {
                            Handles.color = Color.green;

                            buttonPosition = path._points[indexWanted] + Camera.current.transform.right * -0.5f;

                            if (Handles.Button(buttonPosition, Quaternion.LookRotation(Camera.current.transform.forward, Camera.current.transform.up),
                                buttonSize, buttonSize, Handles.DotHandleCap))
                            {
                                Vector3 diff = path._points[indexWanted + 1] - path._points[indexWanted];
                                Vector3 direction = diff.normalized;

                                path.AddPoint(path._points[indexWanted] + direction, indexWanted + 1);

                                Undo.RegisterCompleteObjectUndo(Target, "PlayerPath changed");
                                EditorUtility.SetDirty(Target);

                                return;
                            }
                        }
                    }
                }

                j++;
            }
        }

        /** Add new points **/
        if (Target._pathMode == PlayerPath.PathMode.Default || Target._pathMode == PlayerPath.PathMode.UIDisabled)
        {
            HandleUtility.AddDefaultControl(GUIUtility.GetControlID(FocusType.Passive));
            Event e = Event.current;

            if (e.type == EventType.MouseDown && Event.current.button == 0)
            {
                Ray worldRay = HandleUtility.GUIPointToWorldRay(Event.current.mousePosition);
                RaycastHit hitInfo;


                if (Physics.Raycast(worldRay, out hitInfo))
                {
                    //if(hitInfo.collider.gameObject.GetComponent<MeshRenderer>())
                    {
                        if (Target._paths != null && Target._paths.Count > 0)
                        {
                            Target._paths[Target._pathSelected].AddPoint(hitInfo.point);

                            Undo.RegisterCompleteObjectUndo(Target, "PlayerPath changed");
                            EditorUtility.SetDirty(Target);
                        }
                    }
                }
            }
        }

        /** Check changes for undo **/
        if (EditorGUI.EndChangeCheck())
        {
            Undo.RegisterCompleteObjectUndo(Target, "Change");
            EditorUtility.SetDirty(Target);
        }
    }

    /// <summary>
    /// Check if the key for multiple points is pressed
    /// </summary>
    /// <param name="value"></param>
    /// <returns></returns>
    public bool SelectMultiplePointsKeyPressed(out bool value)
    {
        Event e = Event.current;
        switch (e.type)
        {
            case EventType.KeyDown:
                {
                    if (Event.current.keyCode == (_multiplePointKey))
                    {
                        value = true;
                        return true;
                    }
                    break;
                }

            case EventType.KeyUp:
                {
                    if (Event.current.keyCode == (_multiplePointKey))
                    {
                        value = false;
                        return true;
                    }
                    break;
                }
        }

        value = false;
        return false;
    }
}

#endif
