// Copyright Semaeopus Ltd. 2017
// This code was created as part of LevelKit on: 2019-11-26 - 9:25
// DO NOT EDIT THIS FILE - Code changes will NOT be picked up and may break your project
// Visit http://wiki.offgridthegame.com for help - Happy Hacking!

using System;
using System.IO;
using System.Net;
using System.Threading;
using System.Net.Sockets;

namespace LevelKitNet
{
    // TODO Look into thread re-use and graceful shutdowns rather than abort()
    
    /// <summary>
    /// A TCP server designed to be run on the game client
    /// </summary>
    public class Server : Service
    {
        /// <summary>
        /// Ther server socket
        /// </summary>
        private readonly Socket m_Server;

        /// <summary>
        /// The list of client sockets, will be populated when connections are made
        /// </summary>
        private Socket m_Client = null;
        
        /// <summary>
        /// Lock for sending data on the client socket
        /// </summary>
        private readonly object m_ClientSendLock = new object();
        
        /// <summary>
        /// Lock for receiving data on the client socket
        /// </summary>
        private readonly object m_ClientReceiveLock = new object();
        
        /// <summary>
        /// THREAD
        /// Listen for any messages from our connected clients
        /// </summary>
        private Thread m_ListenForMessagesThread;

        /// <summary>
        /// Result of the accept function
        /// </summary>
        private IAsyncResult m_AcceptResult = null;

        /// <summary>
        /// Is the server listening for messages?
        /// </summary>
        private bool m_IsListening = false;

        /// <summary>
        /// Initialise the server
        /// </summary>
        public Server()
        {
            m_Server  = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp)
            {
                NoDelay = true,
            };
        }

        /// <summary>
        /// Begin listening for clients
        /// </summary>
        public void Start()
        {
            try
            {
                m_Server.Bind(new IPEndPoint(IPAddress.Parse("127.0.0.1"), m_Port));
                m_Server.Listen(8);
                m_AcceptResult = m_Server.BeginAccept(OnAcceptFinish, null);

                m_IsListening = true;
                m_ListenForMessagesThread = new Thread(Thread_ListenForMessages)
                {
                    Name = "LeveKitNet - Server Listen For Messages"
                };
            }
            catch (SocketException e)
            {
                Log("Error starting server {0}", e.Message);
                m_ListenForMessagesThread.Abort();
            }
        }
        
        /// <summary>
        /// Shut everything down and disconnect
        /// </summary>
        public void Stop()
        {
            if (ClientConnected())
            {
                Send(new DisconnectMsg());
            }

            if (m_Client != null)
            {
                m_Client.LingerState = new LingerOption(false, 0);
                m_Client.Close();
            }

            if (m_Server != null)
            {
                m_Server.LingerState = new LingerOption(false, 0);
                m_Server.Close();
            }

            if (m_ListenForMessagesThread.IsAlive)
            {
                m_IsListening = false;
                m_ListenForMessagesThread.Join();
            }
        }

        /// <summary>
        /// Pump the message queue and check if we should be listening for a connection again
        /// </summary>
        public override void Update()
        {
            base.Update();
            bool shouldLookForClient = (m_AcceptResult == null ||
                                        (m_AcceptResult.IsCompleted &&
                                         !ClientConnected()));

            if (shouldLookForClient)
            {
                try
                {
                    m_AcceptResult = m_Server.BeginAccept(OnAcceptFinish, null);
                }
                catch (SocketException)
                {
                    // do nothing.
                }
            }
        }

        /// <summary>
        /// Finish up request to accept a new connection
        /// </summary>
        /// <param name="result"></param>
        private void OnAcceptFinish(IAsyncResult result)
        {
            try
            {
                m_Client = m_Server.EndAccept(result);
                    
                // TODO Cache this empty messages?
                    
                // Let the client know we've connected
                Send(new ConnectMsg());
                m_ListenForMessagesThread.Start();
            }
            catch (SocketException ex )
            {
                Log("Failed to accept new client \"{0}\"", ex.Message);
            }
        }

        /// <summary>
        /// Does the server have any clients?
        /// </summary>
        public bool ClientConnected()
        {
            if (null != m_Client)
            {
                // Code from https://stackoverflow.com/questions/2661764/how-to-check-if-a-socket-is-connected-disconnected-in-c
                bool part1 = m_Client.Poll(/*1000*/100, SelectMode.SelectRead);
                bool part2 = (m_Client.Available == 0);
                return !part1 || !part2;
            }
            return false;
        }

        /// <summary>
        /// Is the server active?
        /// </summary>
        public bool IsActive()
        {
            return ClientConnected() && m_ListenForMessagesThread.IsAlive;
        }

        /// <summary>
        /// Loop listening for messages from clients
        /// </summary>
        private void Thread_ListenForMessages()
        {
            while (m_IsListening)
            {
                lock (m_ClientReceiveLock)
                {
                    try
                    {
                        NetworkStream stream = new NetworkStream(m_Client);
                        BinaryReader reader = new BinaryReader(stream);
                        if (stream.DataAvailable && stream.CanRead)
                        {
                            int messageHash = reader.ReadInt32();

                            NetMessage message = CreateMessageFromHash(messageHash);
                            if (message != null)
                            {
                                message.Deserialise(reader);
                                AddMessage(message);
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        Log("Client disconnected: {0}", e.Message);
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Send a message to all clients
        /// </summary>
        /// <param name="message"></param>
        public void Send(NetMessage message)
        {
            lock (m_ClientSendLock)
            {
                try
                {
                    BinaryWriter writer = new BinaryWriter(new NetworkStream(m_Client));

                    // Send hash of the message name so it can be re-created on the other side
                    writer.Write(message.GetType().Name.GetHashCode());
                    
                    // Serialise the message
                    message.Serialise(writer);
                }
                catch (Exception e)
                {
                    Log("Client disconnected: {0}", e.Message);
                }
            }
        }
    }
}
