// Copyright Semaeopus Ltd. 2017
// This code was created as part of LevelKit on: 2019-11-26 - 9:25
// DO NOT EDIT THIS FILE - Code changes will NOT be picked up and may break your project
// Visit http://wiki.offgridthegame.com for help - Happy Hacking!

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace LevelKitNet
{
	/// <summary>
	/// Provides members and logic that all network services should provide
	/// </summary>
	public abstract class Service
	{
		/// <summary>
		/// The port our network services will use
		/// </summary>
		protected const int m_Port = 1337;

		/// <summary>
		/// A dictionary that maps a callback to each type of message
		/// </summary>
		private readonly Dictionary<int, Action<NetMessage>> m_CallbackRegistry =
			new Dictionary<int, Action<NetMessage>>(128);
		
		/// <summary>
		/// Lock for threaded access to the registry
		/// </summary>
		private readonly object m_RegistryLock = new object();
		
		/// <summary>
		/// A queue of messages that have been added per frame
		/// </summary>
		private readonly Queue<NetMessage> m_MessageQueue = new Queue<NetMessage>(64);
		
		/// <summary>
		/// Lock for threaded access to the message queue
		/// </summary>
		private readonly object m_MessageQueueLock = new object();
		
		/// <summary>
		/// Static dictionary mapping message name hashes to types for quick re-creation on reciver side
		/// </summary>
		private static Dictionary<int, Type> m_MessHashTypes = null;

		/// <summary>
		/// Initialise static hash dictionary
		/// </summary>
		protected Service()
		{
			if (m_MessHashTypes == null)
			{
				m_MessHashTypes = new Dictionary<int, Type>();
				
				Type[] messageTypeArray = (from messageType in Assembly.GetExecutingAssembly().GetTypes()
					where messageType.IsSubclassOf(typeof(NetMessage))
					select messageType).ToArray();

				foreach (Type msgType in messageTypeArray)
				{
					m_MessHashTypes[msgType.Name.GetHashCode()] = msgType;
				}
			}
		}

		/// <summary>
		/// Register a callback to when a specific message type is received 
		/// </summary>
		/// <param name="callFunc"></param>
		/// <typeparam name="MessageType"></typeparam>
		public void RegisterCallback<MessageType>(Action<NetMessage> callFunc) where MessageType : NetMessage
		{
			lock (m_RegistryLock)
			{
				int hash = typeof(MessageType).Name.GetHashCode();
				
				m_CallbackRegistry[hash] = callFunc;
			}
		}

		/// <summary>
		/// Trigger a callback for a specific message
		/// </summary>
		/// <param name="hash"></param>
		/// <param name="message"></param>
		private void TriggerCallback(int hash, NetMessage message)
		{
			lock (m_RegistryLock)
			{
				if (m_CallbackRegistry.ContainsKey(hash))
				{
					if (m_CallbackRegistry[hash] != null)
					{
						try
						{
							m_CallbackRegistry[hash].Invoke(message);
						}
						catch (Exception e)
						{
							UnityEngine.Debug.LogErrorFormat("Exception triggered during NetMessage callback. '{0}'", e.Message);
						}
					}
				}
			}
		}

		/// <summary>
		/// Add a message to the message queue for next frame
		/// </summary>
		/// <param name="message"></param>
		protected void AddMessage(NetMessage message)
		{
			lock (m_MessageQueueLock)
			{
				m_MessageQueue.Enqueue(message);
			}
		}
		
		/// <summary>
		/// Run through the message queue an trigger all callbacks
		/// </summary>
		public virtual void Update()
		{
			lock (m_MessageQueueLock)
			{
               // if(m_MessageQueue != null || m_MessageQueue.Count > 0)
                {
                    foreach (NetMessage message in m_MessageQueue)
                    {
                        TriggerCallback(message.GetType().Name.GetHashCode(), message);
                    }

                    m_MessageQueue.Clear();
                }
            }
		}

		/// <summary>
		/// Create a message from its hash 
		/// </summary>
		/// <param name="hash"></param>
		/// <returns></returns>
		protected NetMessage CreateMessageFromHash(int hash)
		{
			if (m_MessHashTypes.ContainsKey(hash))
			{
				return Activator.CreateInstance(m_MessHashTypes[hash]) as NetMessage;
			}

			return null;
		}

		/// <summary>
		/// Log any messages
		/// </summary>
		/// <remarks>Unity's Debug.Log _should_ be thread safe</remarks>
		/// <param name="message"></param>
		protected void Log(string message)
		{	
			UnityEngine.Debug.Log("<color=silver>[Net] </color>" + message);
		}
		
		/// <summary>
		/// Log any messages
		/// </summary>
		/// <remarks>Unity's Debug.Log _should_ be thread safe</remarks>
		/// <param name="message"></param>
		/// <param name="args"></param>
		protected void Log(string message, params object[] args)
		{	
			UnityEngine.Debug.LogFormat("<color=silver>[Net] </color>" + message, args);
		}
	}
}
