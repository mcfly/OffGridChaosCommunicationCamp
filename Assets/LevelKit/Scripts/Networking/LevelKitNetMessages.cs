// Copyright Semaeopus Ltd. 2017
// This code was created as part of LevelKit on: 2019-11-26 - 9:25
// DO NOT EDIT THIS FILE - Code changes will NOT be picked up and may break your project
// Visit http://wiki.offgridthegame.com for help - Happy Hacking!

using System.Collections.Generic;
using System.IO;
using UnityEngine;
// NetMessages are created via reflection, disable invalid warnings
// ReSharper disable ClassNeverInstantiated.Global

namespace LevelKitNet
{
    /// <summary>
    /// Base class for a message that can be sent over the network
    /// </summary>
    public abstract class NetMessage
    {
        /// <summary>
        /// Write any required data into the binary writer class
        /// </summary>
        /// <param name="writer"></param>
        public abstract void Serialise(BinaryWriter writer);

        /// <summary>
        /// Read the data from the binary writer
        /// </summary>
        /// <remarks>Must read exactly the same amount of data as written</remarks>
        /// <param name="reader"></param>
        public abstract void Deserialise(BinaryReader reader);
    }

    /// <summary>
    /// Message sent to the when the client has connected
    /// </summary>
    public class ConnectMsg : NetMessage
    {
        public override void Deserialise(BinaryReader reader) { }
        public override void Serialise(BinaryWriter writer) { }
    }

    /// <summary>
    /// Message sent to the when the client has disconnected
    /// </summary>
    public class DisconnectMsg : NetMessage
    {
        public override void Deserialise(BinaryReader reader) { }
        public override void Serialise(BinaryWriter writer) { }
    }

    /// <summary>
    /// Net message to start a mission
    /// </summary>
    public class StartMissionMsg : NetMessage
    {
        /// <summary>
        /// The absolute path to the mission to load
        /// </summary>
        public string missionPath = string.Empty;

        public override void Deserialise(BinaryReader reader)
        {
            missionPath = reader.ReadString();
        }

        public override void Serialise(BinaryWriter writer)
        {
            writer.Write(missionPath);
        }
    }

    /// <summary>
    /// (Empty) Net message to stop the current mission
    /// </summary>
    public class StopMissionMsg : NetMessage
    {
        public override void Deserialise(BinaryReader reader) { }
        public override void Serialise(BinaryWriter writer) { }
    }

    /// <summary>
    /// Net message to send a log from the game server to LevelKit
    /// </summary>
    public class SendLogMsg : NetMessage
    {
        public LogType logType = LogType.Log;
        public string logMessage = string.Empty;

        public override void Deserialise(BinaryReader reader)
        {
            logType = (LogType)reader.ReadInt32();
            logMessage = reader.ReadString();
        }

        public override void Serialise(BinaryWriter writer)
        {
            writer.Write((int)logType);
            writer.Write(logMessage);
        }
    }

    /// <summary>
    /// Lets the client know what scene the game is in
    /// </summary>
    public class GameStateMsg : NetMessage
    {
        public string sceneName = string.Empty;

        public override void Deserialise(BinaryReader reader)
        {
            sceneName = reader.ReadString();
        }

        public override void Serialise(BinaryWriter writer)
        {
            writer.Write(sceneName);
        }
    }

    /// <summary>
    /// Inform the game that we'd like to upload a mod
    /// </summary>
    public class UploadModMsg : NetMessage
    {
        public string modPath = string.Empty;
        public string iconPath = string.Empty;
        public ModDefinition definition = new ModDefinition();

        // This _MUST_ match values in UGCItem.VisibilityType ( which in turn matches the steamworks api values)
        public enum Visibility
        {
            Public = 0,
            FriendsOnly = 1,
            Private = 2,
        }

        public Visibility visibility = Visibility.Private;

        public override void Serialise(BinaryWriter writer)
        {
            writer.Write(modPath);
            writer.Write(iconPath);
            writer.Write((int)visibility);
            writer.Write(definition.id);
            writer.Write((int)definition.type);
            writer.Write(definition.name);
            writer.Write(definition.description);
        }

        public override void Deserialise(BinaryReader reader)
        {
            modPath = reader.ReadString();
            iconPath = reader.ReadString();
            visibility = (Visibility)reader.ReadInt32();
            definition.id = reader.ReadInt64();
            definition.type = (ModDefinition.Type)reader.ReadInt32();
            definition.name = reader.ReadString();
            definition.description = reader.ReadString();
        }
    }

    /// <summary>
    /// Send back to the client when an upload was completed
    /// </summary>
    public class CompletedUploadMsg : NetMessage
    {
        public bool wasSuccess = false;
        public long id = -1;
        public string modPath = string.Empty;

        public override void Serialise(BinaryWriter writer)
        {
            writer.Write(wasSuccess);
            writer.Write(id);
            writer.Write(modPath);
        }

        public override void Deserialise(BinaryReader reader)
        {
            wasSuccess = reader.ReadBoolean();
            id = reader.ReadInt64();
            modPath = reader.ReadString();
        }
    }

    /// <summary>
    /// Send progress and progress text to a client
    /// </summary>
    public class ProgressMsg : NetMessage
    {
        public long progress = -1;
        public string progressText = string.Empty;

        public override void Serialise(BinaryWriter writer)
        {
            writer.Write(progress);
            writer.Write(progressText);
        }

        public override void Deserialise(BinaryReader reader)
        {
            progress = reader.ReadInt64();
            progressText = reader.ReadString();
        }
    }

    /// <summary>
    /// Empty message that indicates the client should clear any progress
    /// </summary>
    public class ClearProgressMsg : NetMessage
    {
        public override void Serialise(BinaryWriter writer) { }
        public override void Deserialise(BinaryReader reader) { }
    }

    /// <summary>
    /// Let LevelKit know build information about the current game client
    /// </summary>
    public class BuildInformationMsg : NetMessage
    {
        public string platform = string.Empty;
        public string dateOfBuild = string.Empty;

        public override void Serialise(BinaryWriter writer)
        {
            writer.Write(platform);
            writer.Write(dateOfBuild);
        }

        public override void Deserialise(BinaryReader reader)
        {
            platform = reader.ReadString();
            dateOfBuild = reader.ReadString();
        }
    }

    /// <summary>
    /// Let the game know about LevelKit's mods
    /// </summary>
    public class CurrentModsMsg : NetMessage
    {
        public List<string> modPaths = new List<string>(16);

        public override void Serialise(BinaryWriter writer)
        {
            writer.Write(modPaths.Count);
            foreach (string path in modPaths)
            {
                writer.Write(path);
            }
        }

        public override void Deserialise(BinaryReader reader)
        {
            int modCount = reader.ReadInt32();
            for (int i = 0; i < modCount; ++i)
            {
                modPaths.Add(reader.ReadString());
            }
        }
    }

    public class AIExplorerMsg : NetMessage
    {
        public bool on = false;
        public override void Serialise(BinaryWriter writer)
        {
            writer.Write(on);
        }

        public override void Deserialise(BinaryReader reader)
        {
            on = reader.ReadBoolean();
        }
    }

    public class AIExplorerDataMsg : NetMessage
    {
        public AIExplorerHelper.AIExplorerDisplayData data = new AIExplorerHelper.AIExplorerDisplayData();

        public override void Serialise(BinaryWriter writer)
        {
            writer.Write(data.agentNames.Count);
            foreach (string s in data.agentNames)
                writer.Write(s);

            writer.Write(data.goals.Count);
            foreach (string s in data.goals)
                writer.Write(s);

            writer.Write(data.targets.Count);
            foreach (string s in data.targets)
                writer.Write(s);

            writer.Write(data.worldState.Count);
            foreach (string s in data.worldState)
                writer.Write(s);

            writer.Write(data.goalState.Count);
            foreach (string s in data.goalState)
                writer.Write(s);

            writer.Write(data.modularGoals.Count);
            foreach (List<string> l in data.modularGoals)
            {
                writer.Write(l.Count);
                foreach (string s in l)
                    writer.Write(s);
            }

            writer.Write(data.actionNames.Count);
            foreach (List<string> l in data.actionNames)
            {
                writer.Write(l.Count);
                foreach (string s in l)
                    writer.Write(s);
            }

            writer.Write(data.actionTargets.Count);
            foreach (List<string> l in data.actionTargets)
            {
                writer.Write(l.Count);
                foreach (string s in l)
                    writer.Write(s);
            }

            writer.Write(data.actionPreconditions.Count);
            foreach (List<string> l in data.actionPreconditions)
            {
                writer.Write(l.Count);
                foreach (string s in l)
                    writer.Write(s);
            }

            writer.Write(data.actionEffects.Count);
            foreach (List<string> l in data.actionEffects)
            {
                writer.Write(l.Count);
                foreach (string s in l)
                    writer.Write(s);
            }
        }

        public override void Deserialise(BinaryReader reader)
        {
            data.Clear();

            {
                int count = reader.ReadInt32();
                for (int i = 0; i < count; ++i)
                {
                    data.agentNames.Add(reader.ReadString());
                }
            }
            {
                int count = reader.ReadInt32();
                for (int i = 0; i < count; ++i)
                {
                    data.goals.Add(reader.ReadString());
                }
            }
            {
                int count = reader.ReadInt32();
                for (int i = 0; i < count; ++i)
                {
                    data.targets.Add(reader.ReadString());
                }
            }
            {
                int count = reader.ReadInt32();
                for (int i = 0; i < count; ++i)
                {
                    data.worldState.Add(reader.ReadString());
                }
            }
            {
                int count = reader.ReadInt32();
                for (int i = 0; i < count; ++i)
                {
                    data.goalState.Add(reader.ReadString());
                }
            }
            {
                int count = reader.ReadInt32();
                for (int i = 0; i < count; ++i)
                {
                    data.modularGoals.Add(new List<string>());
                    int count2 = reader.ReadInt32();
                    for (int j = 0; j < count2; ++j)
                    {
                        data.modularGoals[i].Add(reader.ReadString());
                    }
                }
            }
            {
                int count = reader.ReadInt32();
                for (int i = 0; i < count; ++i)
                {
                    data.actionNames.Add(new List<string>());
                    int count2 = reader.ReadInt32();
                    for (int j = 0; j < count2; ++j)
                    {
                        data.actionNames[i].Add(reader.ReadString());
                    }
                }
            }
            {
                int count = reader.ReadInt32();
                for (int i = 0; i < count; ++i)
                {
                    data.actionTargets.Add(new List<string>());
                    int count2 = reader.ReadInt32();
                    for (int j = 0; j < count2; ++j)
                    {
                        data.actionTargets[i].Add(reader.ReadString());
                    }
                }
            }
            {
                int count = reader.ReadInt32();
                for (int i = 0; i < count; ++i)
                {
                    data.actionPreconditions.Add(new List<string>());
                    int count2 = reader.ReadInt32();
                    for (int j = 0; j < count2; ++j)
                    {
                        data.actionPreconditions[i].Add(reader.ReadString());
                    }
                }
            }
            {
                int count = reader.ReadInt32();
                for (int i = 0; i < count; ++i)
                {
                    data.actionEffects.Add(new List<string>());
                    int count2 = reader.ReadInt32();
                    for (int j = 0; j < count2; ++j)
                    {
                        data.actionEffects[i].Add(reader.ReadString());
                    }
                }
            }
        }
    }
}
