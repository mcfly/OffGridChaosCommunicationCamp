// Copyright Semaeopus Ltd. 2017
// This code was created as part of LevelKit on: 2019-11-26 - 9:25
// DO NOT EDIT THIS FILE - Code changes will NOT be picked up and may break your project
// Visit http://wiki.offgridthegame.com for help - Happy Hacking!

using System;
using System.Collections;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Serialization;
#if GAME_CORE
using MoonSharp.Interpreter;
#endif // GAME_CORE
#if UNITY_EDITOR
using UnityEditor;
#endif

[Serializable]
public class InteractionEvent : UnityEvent<GameObject> {}

[Serializable]
public class MissionObjectSaveInfo
{
    public string name = string.Empty;
    public bool enabled = true;
    public bool triggered = false;
}

[DisallowMultipleComponent]
public class MissionObject : MonoBehaviour, ISerializationCallbackReceiver
{
    #if GAME_CORE
    [LuaApiEnum(name = "MissionObjectType")]
    #endif
    public enum MissionObjectType
    {
        // ONLY ADD NEW TYPES TO THE END
        // OTHERWISE IT WILL BREAK BACK COMPAT :)
        Trigger,
        Interaction,
        Spawn,
        Hackable,
        Generic,
        Deprecated,
		Timeline,
    }

    //SJA: I'm putting these here as I am optimistic that we can get rid of them after a month or so once they upgrade the data.
    public void OnBeforeSerialize()   { /* empty */   }
    public void OnAfterDeserialize()
    {
        switch(type)
        {
            case MissionObjectType.Trigger:
                typeBitField = MissionObjectTypeMask.Trigger;
                break;
            case MissionObjectType.Interaction:
                typeBitField = MissionObjectTypeMask.Interaction;
                break;
            case MissionObjectType.Spawn:
                typeBitField = MissionObjectTypeMask.Spawn;
                break;
            case MissionObjectType.Hackable:
                typeBitField = MissionObjectTypeMask.Hackable;
                break;
            case MissionObjectType.Deprecated:
                break;
			case MissionObjectType.Timeline:
				typeBitField = MissionObjectTypeMask.Timeline;
				break;
            default:
                typeBitField = MissionObjectTypeMask.Generic;
                break;                
        }

        type = MissionObjectType.Deprecated;
    }
    // end 

    [Flags]
    public enum MissionObjectTypeMask
    {
        Trigger = 1 << 0,
        Interaction = 1 << 1,
        Spawn = 1 << 2,
        Hackable = 1 << 3,
        Generic = 1 << 4,
		Deprecated = 1 << 5,
		Timeline = 1 << 6,
    }

    #if GAME_CORE
    [LuaApiEnum(name = "InteractionType")]
    #endif
    public enum InteractionType
    {
        Grab,
        OpenDoor,
        Scanning,
    }

    public IOffGridMission mission;

    // The object type
    public MissionObjectType type = MissionObjectType.Deprecated;
    public MissionObjectTypeMask typeBitField = MissionObjectTypeMask.Generic;

    // Trigger
    public bool triggerOnce = true;
    public bool triggered { private set; get; }

    // Interaction
    [FormerlySerializedAs("InteractionStyle")]
    public  InteractionType     interactionType;
    public  Transform           HandMarker;
    public  bool                ShouldPreInteract;
    public  bool                interactOnce = false;
            
    public  InteractionEvent    OnInteractionCheck;
    public  InteractionEvent    OnInteractionStart;
    public  InteractionEvent    OnInteractionStop;

    // Movement
    public bool isMoving { get { return movementEnumerator != null; } }
    private IEnumerator movementEnumerator = null;

#if GAME_CORE
    public DynValue Lua_OnTriggerEnter;
	public DynValue Lua_OnTriggerStay;
	public DynValue Lua_OnTriggerExit;
    public DynValue Lua_OnPreInteract;
    public DynValue Lua_OnStartInteracting;
    public DynValue Lua_OnStopInteracting;
	public DynValue Lua_OnTimelinePlay;
	public DynValue Lua_OnTimelinePause;
	public DynValue Lua_OnTimelineStop;
#endif // GAME_CORE

#if UNITY_EDITOR
	public  bool DisplayUnityEvents;
#endif // UNITY_EDITOR

    public bool IsTrigger()     { return (typeBitField & MissionObjectTypeMask.Trigger) != 0; }
    public bool IsInteraction() { return (typeBitField & MissionObjectTypeMask.Interaction) != 0; }
    public bool IsSpawn()       { return (typeBitField & MissionObjectTypeMask.Spawn) != 0; }
    public bool IsHackable()    { return (typeBitField & MissionObjectTypeMask.Hackable) != 0; }
	public bool IsTimeline() { return (typeBitField & MissionObjectTypeMask.Timeline) != 0; }
	public bool IsType(MissionObjectTypeMask t) { return (typeBitField & t) != 0; }
    public void SetType(MissionObjectTypeMask t) { typeBitField = typeBitField | t; }

    private void Start()
    {
#if GAME_CORE
        if (OnInteractionCheck  == null) { OnInteractionCheck   = new InteractionEvent(); }
        if (OnInteractionStart  == null) { OnInteractionStart   = new InteractionEvent(); }
        if (OnInteractionStop   == null) { OnInteractionStop    = new InteractionEvent(); }
#endif
    }

#if GAME_CORE
    private void OnTriggerEnter(Collider other)
    {
        if (IsTrigger())
        {
            if (!(triggerOnce && triggered) &&
                Lua_OnTriggerEnter != null &&
                Lua_OnTriggerEnter.Type == DataType.Function)
            {
                mission.MissionCall(Lua_OnTriggerEnter, other.name);
            }
            triggered = true;
        }
    }

	private void OnTriggerStay(Collider other) {
		if (IsTrigger()) {
			if (!(triggerOnce && triggered) &&
				Lua_OnTriggerStay != null &&
				Lua_OnTriggerStay.Type == DataType.Function) {
				mission.MissionCall(Lua_OnTriggerStay, other.name, Time.time);
			}
			triggered = true;
		}
	}

	private void OnTriggerExit(Collider other)
    {
        if (IsTrigger())
        {
            if (!(triggerOnce && triggered) &&
            Lua_OnTriggerExit != null &&
            Lua_OnTriggerExit.Type == DataType.Function)
            {
                mission.MissionCall(Lua_OnTriggerExit, other.name);
            }
            triggered = true;
        }
    }

    public bool OnPreInteract(GameObject interactor, bool isFirstPress)
    {
        Debug.Log("Called OnPreInteract.", gameObject);

        // Most interactible objects are simple "yes, whatever" things, so unless we've turned on the ticket
        // mechanism, just say "yes, interact now."
        if (!ShouldPreInteract)
            return true;

        bool result = false;

        // Create and fill out the ticket that we're going to pass to all the other components on this object.

        DynValue preInteractFunction = Lua_OnPreInteract;
        if ( preInteractFunction.IsNotNil() && preInteractFunction.Type == DataType.Function)
        {
            DynValue res = mission.MissionCall(preInteractFunction, interactor.name);
            if (res.Type == DataType.Boolean)
            {
                result = res.Boolean;
            }
            else
            {
                Logger.Log(Channel.Lua, Priority.Error, "OnPreInteract function must return a bool value! - Assuming true");
                result = true;
            }
        }
        OnInteractionCheck.Invoke(interactor);

        return result;
    }

    public void OnStartInteracting(GameObject interactor)
    {
        Debug.Log("Called OnStartInteracting.", gameObject);
        if (Lua_OnStartInteracting != null && Lua_OnStartInteracting.Type == DataType.Function)
        {
            mission.MissionCall(Lua_OnStartInteracting, interactor.name);
        }
        OnInteractionStart.Invoke(interactor);
    }

    public void OnStopInteracting(GameObject interactor)
    {
        if (Lua_OnStopInteracting != null && Lua_OnStopInteracting.Type == DataType.Function)
        {
            mission.MissionCall(Lua_OnStopInteracting, interactor.name);
        }
        OnInteractionStop.Invoke(interactor);

        // Disable ourselces if we don't want to be interactable anymore
        enabled = !interactOnce;
    }

    public Vector3 GetHandPosition()
    {
        return HandMarker != null ? HandMarker.position : transform.position;
    }

    public bool HasHandPosition()
    {
        return HandMarker != null;
    }

    public MissionObjectSaveInfo SaveState()
    {
        return new MissionObjectSaveInfo
        {
            enabled = this.isActiveAndEnabled,
            triggered = this.triggered,
            name = this.name,
        };
    }

    public void ResetStateOnLoad(MissionObjectSaveInfo saveInfo)
    {
        enabled = saveInfo.enabled;
        triggered = saveInfo.triggered;
    }

#endif // GAME_CORE

    public void OnDrawGizmos()
    {
        Collider col = gameObject.GetComponent<Collider>();
        Vector3 position = transform.position;
        if (col)
        {
            position = col.bounds.center;
        }
        
        if(IsHackable())
        {
            Gizmos.DrawIcon(position, "HackableDevice");
        }
        else if(IsInteraction())
        {
            Vector3 pos = HandMarker ? HandMarker.position : position;
            Gizmos.DrawIcon(pos, "Interaction");
        }
        else if(IsSpawn())
        {
            Gizmos.DrawIcon(position, "SpawnPoint");
                    
            // Draw an arrow of the characters starting rotation
            // Code influenced by http://wiki.unity3d.com/index.php?title=DrawArrow
            Gizmos.DrawRay(position, transform.forward);
            const float arrowHeadAngle = 20.0f;
            const float arrowHeadLength = 0.250f;
                    
            Vector3 right = Quaternion.LookRotation(transform.forward) * Quaternion.Euler(0,180+arrowHeadAngle,0) * new Vector3(0,0,1);
            Vector3 left = Quaternion.LookRotation(transform.forward) * Quaternion.Euler(0,180-arrowHeadAngle,0) * new Vector3(0,0,1);
            Gizmos.DrawRay(position + transform.forward, right * arrowHeadLength);
            Gizmos.DrawRay(position + transform.forward, left * arrowHeadLength);
        }
        else if(IsTrigger())
        {
            Gizmos.DrawIcon(position, "Trigger");
            if (col && !(triggerOnce && triggered))
            {
				Gizmos.color = Color.cyan;
				Matrix4x4 oldMat = Gizmos.matrix;

				if (col is BoxCollider) {
					BoxCollider bc = col as BoxCollider;
					Gizmos.matrix = transform.localToWorldMatrix;
					Gizmos.DrawWireCube(bc.center, bc.size);
				}
				else {
					Gizmos.matrix *= Matrix4x4.TRS(col.bounds.center, col.transform.rotation, col.bounds.size);
					Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
				}
				Gizmos.matrix = oldMat;
			}
        }
        else
        {
            Gizmos.DrawIcon(position, "GenericMissionObject");
        }
    }

#if GAME_CORE
    public void MoveToObject(MissionObject other, float timeToMoveSecs,
                             Func<Vector3, Vector3, float, Vector3> moveFunc,
                             Func<Quaternion, Quaternion, float, Quaternion> rotFunc)
    {
        if (movementEnumerator != null)
        {
            StopCoroutine(movementEnumerator);
        }

        movementEnumerator = MoveToObject_Coroutine(other, timeToMoveSecs, moveFunc, rotFunc);
        StartCoroutine(movementEnumerator);
    }

    public void MoveToPosition(Vector3 position, float timeToMoveSecs, bool inWorldSpace, Func<Vector3, Vector3, float, Vector3> moveFunc)
    {
        if (movementEnumerator != null)
        {
            StopCoroutine(movementEnumerator);
        }

        movementEnumerator = MoveToPosition_Coroutine(position, timeToMoveSecs, inWorldSpace, moveFunc);
        StartCoroutine(movementEnumerator);
    }

    private IEnumerator MoveToObject_Coroutine(MissionObject other, float timeToMoveSecs,
                                               Func<Vector3, Vector3, float, Vector3> moveFunc,
                                               Func<Quaternion, Quaternion, float, Quaternion> rotFunc)
    {
        float t = 0;
        Vector3 startPos = transform.position;
        Quaternion startRot = transform.rotation;
        while (t < 1)
        {
            t += Time.deltaTime / timeToMoveSecs;
            transform.position = moveFunc(startPos, other.transform.position, t);
            transform.rotation = rotFunc(startRot, other.transform.rotation, t);
            yield return null;
        }
    }

    private IEnumerator MoveToPosition_Coroutine(Vector3 position, float timeToMoveSecs, bool inWorldSpace,
                                                  Func<Vector3, Vector3, float, Vector3> moveFunc)
    {
        float t = 0;
        Vector3 startPos = inWorldSpace ? transform.position : transform.localPosition;
        while (t < 1)
        {
            t += Time.deltaTime / timeToMoveSecs;
            if (inWorldSpace)
            {
                transform.position = moveFunc(startPos, position, t);
            }
            else
            {
                transform.localPosition = moveFunc(startPos, position, t);
            }
            yield return null;
        }
    }

	public void OnTimelinePlay(UnityEngine.Playables.PlayableDirector director) {
		if (Lua_OnTimelinePlay != null && Lua_OnTimelinePlay.Type == DataType.Function) {
			mission.MissionCall(Lua_OnTimelinePlay, director.gameObject.name);
		}
	}

	public void OnTimelinePause(UnityEngine.Playables.PlayableDirector director) {
		if (Lua_OnTimelinePause != null && Lua_OnTimelinePause.Type == DataType.Function) {
			mission.MissionCall(Lua_OnTimelineStop, director.gameObject.name);
		}
	}

	public void OnTimelineStop(UnityEngine.Playables.PlayableDirector director) {
		if (Lua_OnTimelineStop != null && Lua_OnTimelineStop.Type == DataType.Function) {
			mission.MissionCall(Lua_OnTimelineStop, director.gameObject.name);
		}
	}

#endif
}


