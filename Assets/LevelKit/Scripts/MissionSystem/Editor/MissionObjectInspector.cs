// Copyright Semaeopus Ltd. 2017
// This code was created as part of LevelKit on: 2019-11-26 - 9:25
// DO NOT EDIT THIS FILE - Code changes will NOT be picked up and may break your project
// Visit http://wiki.offgridthegame.com for help - Happy Hacking!

using System;
using UnityEngine;
using UnityEditor;

[CustomEditor(typeof(MissionObject))]
[CanEditMultipleObjects]
public class MissionObjectInspector : Editor
{
    public override void OnInspectorGUI()
    {
        serializedObject.Update();

        MissionObject mo = target as MissionObject;

        // The type of mission object
        SerializedProperty missionObjectTypeProperty = serializedObject.FindProperty("typeBitField");
        MissionObject.MissionObjectTypeMask missionObjectType = (MissionObject.MissionObjectTypeMask) missionObjectTypeProperty.intValue;
        missionObjectType = (MissionObject.MissionObjectTypeMask) EditorGUILayout.EnumMaskField("Mission Object Type", missionObjectType);

        if (missionObjectType == 0)
        {
            missionObjectType = MissionObject.MissionObjectTypeMask.Generic;
        }
        else
        {   // setting to 'all' lazily sets it to -1. This will break things if and when the enum is extended, so instead mask out the unused entries.
            MissionObject.MissionObjectTypeMask allMask = 0;
            foreach (MissionObject.MissionObjectTypeMask enumValue in System.Enum.GetValues(typeof(MissionObject.MissionObjectTypeMask)))
            {
                allMask = allMask | enumValue;
            }
            missionObjectType = missionObjectType & allMask;
        }
        mo.typeBitField = missionObjectType;
                
        EditorGUILayout.Space();

        if((missionObjectType & MissionObject.MissionObjectTypeMask.Trigger) != 0)        
        {
            EditorGUILayout.PropertyField(serializedObject.FindProperty("triggerOnce"), new GUIContent("Trigger Only Once"));
        }

        if ((missionObjectType & MissionObject.MissionObjectTypeMask.Interaction) != 0)
        {
            // Interaction Style
            EditorGUILayout.PropertyField(serializedObject.FindProperty("interactionType"), new GUIContent("Interaction Style"));

            // Should pre interact
            EditorGUILayout.PropertyField(serializedObject.FindProperty("ShouldPreInteract"), new GUIContent("Should Pre-Interact"));

            EditorGUILayout.PropertyField(serializedObject.FindProperty("interactOnce"), new GUIContent("Only interact once"));

            // Hand Marker
            EditorGUILayout.PropertyField(serializedObject.FindProperty("HandMarker"), new GUIContent("Hand Position"));

            // Allow editng of Unity events if selected
            var DisplayUnityEvents = serializedObject.FindProperty("DisplayUnityEvents");
            DisplayUnityEvents.boolValue = EditorGUILayout.BeginToggleGroup("Trigger Unity Events", DisplayUnityEvents.boolValue);
            if (DisplayUnityEvents.boolValue)
            {
                EditorGUILayout.PropertyField(serializedObject.FindProperty("OnInteractionCheck"));
                EditorGUILayout.PropertyField(serializedObject.FindProperty("OnInteractionStart"));
                EditorGUILayout.PropertyField(serializedObject.FindProperty("OnInteractionStop"));
            }
            EditorGUILayout.EndToggleGroup();
        }

        EditorGUILayout.Space();

        EditorGUILayout.LabelField("Validation", EditorStyles.boldLabel);

        if (!serializedObject.isEditingMultipleObjects)
        {
            bool allOk = ValidateObject(serializedObject.targetObject as MissionObject, true);
            if (allOk)
            {
                EditorGUILayout.HelpBox(
                    "No errors detected",
                    MessageType.None);
            }
        }
        else
        {
            EditorGUILayout.HelpBox(
                "Can't validate mutliple objects, please select objects indiviually to validate",
                MessageType.Warning);
        }
        serializedObject.ApplyModifiedProperties();

    }

    public static bool ValidateObject(MissionObject missionObject, bool drawGUI)
    {
        bool allOK = true;
        Undo.RecordObject(missionObject, "Fix " + missionObject.name);

        if (missionObject.IsTrigger())
        {
            allOK &= ValidateTriggerObject(missionObject, drawGUI);
        }
        if (missionObject.IsInteraction())
        {
            allOK &= ValidateInteractionObject(missionObject, drawGUI);
        }
        if (missionObject.IsSpawn())
        {
            allOK &= ValidateSpawnObject(missionObject, drawGUI);
        }
        if (missionObject.IsHackable())
        {
            allOK &= ValidateHackableObject(missionObject, drawGUI);
        }
		if (missionObject.IsTimeline()) {
			allOK &= ValidateTimelineObject(missionObject, drawGUI);
		}

		return allOK;
    }

    // Triggers
    private static bool ValidateTriggerObject(MissionObject missionObject, bool drawGUI)
    {
        bool allOK = true;

        // Check collider
        Collider col = missionObject.GetComponent<Collider>();
        if (col == null)
        {
            allOK = false;
            if (drawGUI)
            {
                EditorGUILayout.BeginHorizontal();
                {
                    EditorGUILayout.SelectableLabel("No collider found", GUILayout.MinWidth(140.0f));
                    if (GUILayout.Button("Fix (Box)"))
                    {
                        col = Undo.AddComponent<BoxCollider>(missionObject.gameObject);
                        col.isTrigger = true;
                    }
                }
                EditorGUILayout.EndHorizontal();
            }
        }
        // Check it's a trigger
        else if(!col.isTrigger)
        {
            allOK = false;
            if (drawGUI)
            {
                EditorGUILayout.BeginHorizontal();
                {
                    EditorGUILayout.SelectableLabel("Is Trigger isn't set", GUILayout.MinWidth(140.0f));
                    if (GUILayout.Button("Fix"))
                    {
                        col.isTrigger = true;
                    }
                }
                EditorGUILayout.EndHorizontal();
            }
        }

        // Check layer
        int correctLayer = LayerMask.NameToLayer("MissionObjects");
        if (missionObject.gameObject.layer != correctLayer)
        {
            allOK = false;
            if (drawGUI)
            {
                EditorGUILayout.BeginHorizontal();
                {
                    EditorGUILayout.SelectableLabel("Incorrect Layer Used (Must be \"MissionObjects\")", GUILayout.MinWidth(140.0f));
                    if (GUILayout.Button("Fix"))
                    {
                        missionObject.gameObject.layer = correctLayer;
                    }
                }
                EditorGUILayout.EndHorizontal();
            }
        }
        return allOK;
    }

    // Interactions
    private static bool ValidateInteractionObject(MissionObject missionObject, bool drawGUI)
    {
        bool allOK = true;

        // Check collider
        Collider col = missionObject.GetComponent<Collider>();
        if (col == null)
        {
            allOK = false;
            if (drawGUI)
            {
                EditorGUILayout.BeginHorizontal();
                {
                    EditorGUILayout.SelectableLabel("No collider found", GUILayout.MinWidth(140.0f));
                    if (GUILayout.Button("Fix (Box)"))
                    {
                        col = Undo.AddComponent<BoxCollider>(missionObject.gameObject);
                    }
                }
                EditorGUILayout.EndHorizontal();
            }
        }

        return allOK;
    }

    // Hackable
    private static bool ValidateHackableObject(MissionObject missionObject, bool drawGUI)
    {
        bool allOK = true;

        // Check layer
        int correctLayer = LayerMask.NameToLayer("MissionObjects");
        if (missionObject.gameObject.layer != correctLayer)
        {
            allOK = false;
            if (drawGUI)
            {
                EditorGUILayout.BeginHorizontal();
                {
                    EditorGUILayout.SelectableLabel("Incorrect Layer Used (Must be \"MissionObjects\")", GUILayout.MinWidth(140.0f));
                    if (GUILayout.Button("Fix"))
                    {
                        missionObject.gameObject.layer = correctLayer;
                    }
                }
                EditorGUILayout.EndHorizontal();
            }
        }

        // Check Tag
        if (!missionObject.CompareTag("HackableDevice"))
        {
            allOK = false;
            if (drawGUI)
            {
                EditorGUILayout.BeginHorizontal();
                {
                    EditorGUILayout.SelectableLabel("Incorrect tag (Must be \"HackableDevice\"", GUILayout.MinWidth(140.0f));
                    if (GUILayout.Button("Fix"))
                    {
                        missionObject.tag = "HackableDevice";
                    }
                }
                EditorGUILayout.EndHorizontal();
            }
        }
        
        // Check collider
        Collider col = missionObject.GetComponent<Collider>();
        if (col == null)
        {
            allOK = false;
            if (drawGUI)
            {
                EditorGUILayout.BeginHorizontal();
                {
                    EditorGUILayout.SelectableLabel("No collider found", GUILayout.MinWidth(140.0f));
                    if (GUILayout.Button("Fix (Box)"))
                    {
                        col = Undo.AddComponent<BoxCollider>(missionObject.gameObject);
                    }
                }
                EditorGUILayout.EndHorizontal();
            }
        }

        return allOK;
    }

    // Spawn
    private static bool ValidateSpawnObject(MissionObject missionObject, bool drawGUI)
    {
        bool allOK = true;

        Collider col = missionObject.GetComponent<Collider>();
        if (col)
        {
            allOK = false;
            if (drawGUI)
            {
                EditorGUILayout.BeginHorizontal();
                {
                    EditorGUILayout.SelectableLabel("Spawns shouldn't have colliders, this will cause issues", GUILayout.MinWidth(140.0f));
                    if (GUILayout.Button("Fix"))
                    {
                        DestroyImmediate(col);
                    }
                }
                EditorGUILayout.EndHorizontal();
            }
        }

        return allOK;
    }

	// Timeline
	private static bool ValidateTimelineObject(MissionObject missionObject, bool drawGUI) {
		bool allOK = true;

		UnityEngine.Playables.PlayableDirector dir = missionObject.GetComponent<UnityEngine.Playables.PlayableDirector>();
		if (dir == null) {
			allOK = false;
			if (drawGUI) {
				EditorGUILayout.BeginHorizontal();
				{
					EditorGUILayout.SelectableLabel("No PlayableDirector found", GUILayout.MinWidth(140.0f));
					if (GUILayout.Button("Fix (PlayableDirector)")) {
						dir = Undo.AddComponent<UnityEngine.Playables.PlayableDirector>(missionObject.gameObject);
						dir.playOnAwake = false;					}
				}
				EditorGUILayout.EndHorizontal();
			}
		}

		TimelineSetup setup = missionObject.GetComponent<TimelineSetup>();
		if (setup == null) {
			allOK = false;
			if (drawGUI) {
				EditorGUILayout.BeginHorizontal();
				{
					EditorGUILayout.SelectableLabel("No TimelineSetup found", GUILayout.MinWidth(140.0f));
					if (GUILayout.Button("Fix (TimelineSetup)")) {
						setup = Undo.AddComponent<TimelineSetup>(missionObject.gameObject);
					}
				}
				EditorGUILayout.EndHorizontal();
			}
		}

		return allOK;
	}
}

