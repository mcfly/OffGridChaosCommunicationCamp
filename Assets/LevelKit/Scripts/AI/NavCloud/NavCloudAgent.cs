// Copyright Semaeopus Ltd. 2017
// This code was created as part of LevelKit on: 2019-11-26 - 9:25
// DO NOT EDIT THIS FILE - Code changes will NOT be picked up and may break your project
// Visit http://wiki.offgridthegame.com for help - Happy Hacking!

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.AI;

namespace NavCloud
{
    public class NavCloudAgent : MonoBehaviour
    {
        public bool isStopped = true;
        public bool hasPath = false;
        public bool pathPending = false; // true while calculating the path
        public float remainingDistance = 0.0f;
        public float stoppingDistance = 2.0f;
        public float maxSpeed = 0.05f;
        public float maxForce = 0.05f;
        public float mass = 1.0f;
        public NavMeshPathStatus pathStatus = NavMeshPathStatus.PathInvalid;

        private bool canUpdatePosition = true;
        public bool updatePosition { get { return canUpdatePosition; } set { SetCanUpdatePosition(updatePosition); } }

        [NonSerialized][HideInInspector] public Vector3 velocity = new Vector3();
        public float speed { get { return velocity.magnitude; } }
        private Vector3 acceleration = new Vector3();
        private Vector3 targetPoint = new Vector3();
        
        private LinkedList<Vector3> path = new LinkedList<Vector3>();

        private Quaternion toLookAtQ = Quaternion.identity;
        
        public void Start()
        {
            toLookAtQ = Quaternion.LookRotation(transform.forward, Vector3.up);
        }

        public void Update()
        {
            if (pathStatus == NavMeshPathStatus.PathComplete && path.Count > 0)
            {
                DoNext();

                Rigidbody rigidbody = GetComponent<Rigidbody>();

                // first point is where we are. third point is our next point. two tangents are midpoints.
                Vector3 desiredVelocity = Vector3.zero;                
                if (path.Count == 1)
                {
                    desiredVelocity = path.First.Value - transform.position;
                }
                else
                {
                    Vector3 p2 = (path.First.Value + transform.position) * 0.5f;
                    Vector3 p4 = (path.First.Value + path.First.Next.Value) * 0.5f;
                    Vector3 aimingAt = CatMullRomInterp(0.05f, transform.position, p2, path.First.Value, p4);
                    desiredVelocity = aimingAt - transform.position;
                }
                float remaining = remainingDistance = desiredVelocity.magnitude;

                // we only want to reveal the remaining distance if
                // we are on the final run
                if (path.Count > 1)
                {
                    remainingDistance = 1000.0f;
                }
                
                float ramped = maxSpeed * (remainingDistance / stoppingDistance);
                float clipped = Mathf.Min(ramped, maxSpeed);
                desiredVelocity = (clipped / remaining) * desiredVelocity;
                Vector3 steer = desiredVelocity - velocity;
                if(steer.magnitude > maxForce)
                {
                    steer = steer.normalized * maxForce;
                }
                velocity = velocity + steer;
                if(velocity.magnitude > maxSpeed)
                {
                    velocity = velocity.normalized * maxSpeed;
                }

                if (rigidbody.isKinematic)
                {
                    rigidbody.velocity = velocity;
                }
                else
                {
                    transform.position += velocity;
                }

                // so, based on the velocity we want to work out the look direction of the drone
                Vector3 toLookAt = velocity.normalized;
                toLookAt.y = 0;
                toLookAt.Normalize();

                if(toLookAt.sqrMagnitude > 0.0f)
                {
                    Vector3 right = Vector3.Cross(Vector3.up, transform.forward);        // right vector
                    float dir = (Vector3.Dot(right, toLookAt) + 1.0f) * 0.5f;

                    Vector3 leftRoll = new Vector3(-0.5f, 1.0f, 0.0f).normalized;
                    Vector3 rightRoll = new Vector3(0.5f, 1.0f, 0.0f).normalized;
                    Vector3 roll = Vector3.Slerp(leftRoll, rightRoll, dir);
                    
                    toLookAtQ = Quaternion.LookRotation(toLookAt, roll);
                }

                if (rigidbody.isKinematic)
                {
                    rigidbody.MoveRotation(toLookAtQ);
                }
                else
                {
                    transform.rotation = Quaternion.Slerp(transform.rotation, toLookAtQ, 0.05f);
                }
            }
        }

        private void DoNext()
        {
            // we need to at least two points in the path to remove one.
            if(path.Count > 1)
            {
                // do a rough calculation to see if we are nearer the next point or its subsequent point
                float toNext = (path.First.Value - transform.position).sqrMagnitude;
                //float toNextNext = (path.First.Next.Value - transform.position).sqrMagnitude;

                //if(toNextNext < toNext) // we are nearer the second point, so remove the first.
                if(toNext < 4.0f)
                {
                    path.RemoveFirst();
                }
            }
        }

        public void SetDestination(Vector3 dest)
        {
            if(pathStatus == NavMeshPathStatus.PathComplete)
            {
                if (path.Count > 0 && dest == path.Last())
                    return;
            }

            pathStatus = NavMeshPathStatus.PathInvalid;

            // get the top of the nav cloud structure
            GameObject navRoot = GameObject.Find("NavCloud");

            if (navRoot == null)
                return;

            NavCloudComponent top = navRoot.GetComponent<NavCloudComponent>();

            NavCloudData.Item currentNode = top.GetNavCloudDataForPosition(transform.position);
            NavCloudData.Item destNode = top.GetNavCloudDataForPosition(dest);

            bool currentLeaf = currentNode != null;
            bool destLeaf = destNode != null;

            if (!currentLeaf && !destLeaf)
            {
                // we are totally off grid (LOLOLOL) so we must try to get directly to the destination
                RaycastHit hitinfo;
                if (!Physics.SphereCast(transform.position, 1.0f, dest - transform.position, out hitinfo, (dest - transform.position).magnitude, 1 << 11))
                {
                    path.Clear();
                    path.AddLast(dest);
                }
            }
            else
            {
                if (!currentLeaf)
                {
                    currentNode = top.BestNodeFor(transform.position);
                }
                if (!destLeaf)
                {
                    destNode = top.BestNodeFor(dest);
                }
            }

            // 
            if (currentNode != null && destNode != null)
            {
                List<NavCloudData.Item> route = top.FindRoute(destNode, currentNode);
                                    
                if (route.Count != 0)
                {
                    path.Clear();

                    if (currentLeaf)
                    {

                    }

                    Bounds bounds = new Bounds();
                    Vector3 size = new Vector3();
                    Vector3 previous = Vector3.zero;

                    for (int i = 0; i < route.Count - 1; ++i)
                    {
                        NavCloudData.Item loopCurrent = route[i];
                        NavCloudData.Item loopNext = route[i + 1];

                        // for each node (but the last), add the position (centre of the node)
                        if (i > 0)
                        {
                            Debug.DrawLine(previous, loopCurrent.position, Color.red, 20.0f, true);
                        }
                        path.AddLast(loopCurrent.position);

                        // and a reasonable intermediate point, which for now can be the closest point 
                        // going from the smaller of the two nodes (current / next) to the other's bounds
                        if (loopNext.size < loopCurrent.size)
                        {
                            size.x = size.y = size.z = loopCurrent.size;
                            bounds.center = loopCurrent.position;
                            bounds.size = size;
                            Vector3 intermediate = bounds.ClosestPoint(loopNext.position);
                            path.AddLast(intermediate);
                            Debug.DrawLine(loopCurrent.position, intermediate, Color.red, 20.0f, true);
                        }
                        else
                        {
                            size.x = size.y = size.z = loopNext.size;
                            bounds.center = loopNext.position;
                            bounds.size = size;
                            Vector3 intermediate = bounds.ClosestPoint(loopCurrent.position);
                            path.AddLast(intermediate);
                            Debug.DrawLine(loopCurrent.position, intermediate, Color.red, 20.0f, true);
                        }

                        previous = loopCurrent.position;
                    }
                    path.AddLast(dest);

                    if (destLeaf)
                    {

                    }

                    if (path.Count > 0)
                    {
                        pathStatus = NavMeshPathStatus.PathComplete;
                        remainingDistance = 1000.0f;
                    }
                }
            }
            
            pathPending = false;
        }

        private void SetCanUpdatePosition(bool tf)
        {
            // do some fun stuff, maybe

            canUpdatePosition = tf;
        }

        public void ResetPath()
        {
            path.Clear();
        }

        public void Warp(Vector3 position)
        {
            transform.position = position;
        }

        private static Vector3 CatMullRomInterp(float t, Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4)
        {
            Vector3 pos = Vector3.zero;

            float t2 = t * t;
            float t3 = t2 * t;

            pos.x = ((-t3 + 2.0f * t2 - t) * p1.x + (3.0f * t3 - 5.0f * t2 + 2.0f) * p2.x + (-3.0f * t3 + 4.0f * t2 + t) * p3.x + (t3 - t2) * p4.x) * 0.5f;
            pos.y = ((-t3 + 2.0f * t2 - t) * p1.y + (3.0f * t3 - 5.0f * t2 + 2.0f) * p2.y + (-3.0f * t3 + 4.0f * t2 + t) * p3.y + (t3 - t2) * p4.y) * 0.5f;
            pos.z = ((-t3 + 2.0f * t2 - t) * p1.z + (3.0f * t3 - 5.0f * t2 + 2.0f) * p2.z + (-3.0f * t3 + 4.0f * t2 + t) * p3.z + (t3 - t2) * p4.z) * 0.5f;

            return pos;
        }
    }
}
