// Copyright Semaeopus Ltd. 2017
// This code was created as part of LevelKit on: 2019-11-26 - 9:25
// DO NOT EDIT THIS FILE - Code changes will NOT be picked up and may break your project
// Visit http://wiki.offgridthegame.com for help - Happy Hacking!

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

#if UNITY_EDITOR
using UnityEditor;
#endif

public class NavCloudBoundaries : MonoBehaviour
{
    [Header("Size")]
    [SerializeField]
    private float _sizeX = 1f;
    public float scaleX { get { return _sizeX; } set { _sizeX = value; } }

    [SerializeField]
    private float _sizeY = 1f;
    public float scaleY { get { return _sizeY; } set { _sizeY = value; } }

    [SerializeField]
    private float _sizeZ = 1f;
    public float scaleZ { get { return _sizeZ; } set { _sizeZ = value; } }


    [Header("Colors")]
    public Color _colorCube = new Color32(245, 239, 66, 127);
    public Color _colorFinalCube = new Color32(230, 60, 60, 110);
    public Color _colorX = new Color32(255, 0, 75, 255);
    public Color _colorY = new Color32(155, 255, 0, 255);
    public Color _colorZ = new Color32(0, 155, 255, 255);

    #region IntersectingOldCode
    //public bool IsIntersecting(Renderer renderer)
    //{
    //    /** Get boundary extremities **/
    //    Vector3 boundaryMin;
    //    Vector3 boundaryMax;
    //    GetBoundaryExtremities(out boundaryMin, out boundaryMax);

    //    ///** Get renderer extremities **/
    //    //Vector3 rendererBoundsMin = renderer.bounds.min;
    //    //Vector3 rendererBoundsMax = renderer.bounds.max;

    //    ///** Check if some part of renderer is inside of the boundary **/
    //    //if (!((rendererBoundsMin.x > boundaryMin.x) && (rendererBoundsMin.x < boundaryMax.x)) ) { return false; }
    //    //if (!((rendererBoundsMin.y > boundaryMin.y) && (rendererBoundsMin.y < boundaryMax.y))) { return false; }
    //    //if (!((rendererBoundsMin.z > boundaryMin.z) && (rendererBoundsMin.z < boundaryMax.z))) { return false; }

    //    //return true;

    //    BoxCollider boxCollider = gameObject.AddComponent<BoxCollider>();
    //    boxCollider.size = new Vector3(_sizeX, _sizeY, _sizeZ);
    //    bool toReturn = boxCollider.bounds.Intersects(renderer.bounds);
    //    DestroyImmediate(boxCollider);

    //    return toReturn;
    //}

    //public bool IsIntersecting(BoxCollider box)
    //{
    //    /** Get boundary extremities **/
    //    Vector3 boundaryMin;
    //    Vector3 boundaryMax;
    //    GetBoundaryExtremities(out boundaryMin, out boundaryMax);


    //    ///** Check if some part of renderer is inside of the boundary **/
    //    BoxCollider boxCollider = gameObject.AddComponent<BoxCollider>();
    //    boxCollider.size = new Vector3(_sizeX, _sizeY, _sizeZ);
    //    bool toReturn = boxCollider.bounds.Intersects(box.bounds);
    //    DestroyImmediate(boxCollider);

    //    return toReturn;
    //}

    //public void GetBoundaryExtremities(out Vector3 boundaryMin, out Vector3 boundaryMax)
    //{
    //    Vector3 transformPositon = transform.position;
    //    float extentX = _sizeX * 0.5f;
    //    float extentY = _sizeY * 0.5f;
    //    float extentZ = _sizeZ * 0.5f;

    //    float minX = transformPositon.x - extentX;
    //    float minY = transformPositon.y - extentY;
    //    float minZ = transformPositon.z - extentZ;
    //    boundaryMin = new Vector3(minX, minY, minZ);

    //    float maxX = transformPositon.x + extentX;
    //    float maxY = transformPositon.y + extentY;
    //    float maxZ = transformPositon.z + extentZ;
    //    boundaryMax = new Vector3(maxX, maxY, maxZ);
    //}
    #endregion

    public void UpdateExternalBounds(out Bounds bounds)
    {
        bounds = new Bounds(transform.position, new Vector3(_sizeX, _sizeY, _sizeZ));
    }

    void OnDrawGizmosSelected()
    {
        // Draw a semitransparent blue cube at the transforms position
        Gizmos.color = _colorCube;
        Gizmos.DrawCube(transform.position, new Vector3(_sizeX, _sizeY, _sizeZ));

        Gizmos.color = _colorFinalCube;
        float maxAxisSize = Mathf.Max(_sizeX, _sizeY, _sizeZ);
        Gizmos.DrawCube(transform.position, new Vector3(maxAxisSize, maxAxisSize, maxAxisSize));
    }
}


#if UNITY_EDITOR
[CustomEditor(typeof(NavCloudBoundaries))]
public class NavCloudBoundaryEditor : Editor
{
    public void OnSceneGUI()
    {
        NavCloudBoundaries thisTarget = (NavCloudBoundaries)target;

        /** Scale slice handles **/
        float size = HandleUtility.GetHandleSize(thisTarget.transform.position) * 2f;
        float snap = 0.5f;

        EditorGUI.BeginChangeCheck();

        // X Scale Slider Handle [Right side] //
        Handles.color = thisTarget._colorX;
        float scaleX_Right = Handles.ScaleSlider(thisTarget.scaleX, thisTarget.transform.position, thisTarget.transform.right, thisTarget.transform.rotation, size, snap);
        float scaleX_Left = Handles.ScaleSlider(thisTarget.scaleX, thisTarget.transform.position, -thisTarget.transform.right, thisTarget.transform.rotation, size, snap);

        // Y Scale Slider Handle //
        Handles.color = thisTarget._colorY;
        float scaleY_Top = Handles.ScaleSlider(thisTarget.scaleY, thisTarget.transform.position, thisTarget.transform.up, thisTarget.transform.rotation, size, snap);
        float scaleY_Bottom = Handles.ScaleSlider(thisTarget.scaleY, thisTarget.transform.position, -thisTarget.transform.up, thisTarget.transform.rotation, size, snap);


        // Z Scale Slider Handle //
        Handles.color = thisTarget._colorZ;
        float scaleZ_Front = Handles.ScaleSlider(thisTarget.scaleZ, thisTarget.transform.position, thisTarget.transform.forward, thisTarget.transform.rotation, size, snap);
        float scaleZ_Back = Handles.ScaleSlider(thisTarget.scaleZ, thisTarget.transform.position, -thisTarget.transform.forward, thisTarget.transform.rotation, size, snap);



        if (EditorGUI.EndChangeCheck())
        {
            Undo.RecordObject(target, "Change Scale Value");
            Undo.RecordObject(thisTarget.transform, "ObjectMoved");

            //thisTarget.scaleX = scaleX;
            //thisTarget.scaleY = scaleY;
            //thisTarget.scaleZ = scaleZ

            UpdateBoundaries(scaleX_Right, scaleX_Left, scaleY_Top, scaleY_Bottom, scaleZ_Front, scaleZ_Back);
        }

        /** Draw cube **/
        Handles.color = thisTarget._colorCube;
        Handles.DrawWireCube(thisTarget.transform.position, new Vector3(thisTarget.scaleX, thisTarget.scaleY, thisTarget.scaleZ));

        Handles.color = thisTarget._colorFinalCube;
        float maxAxisSize = Mathf.Max(thisTarget.scaleX, thisTarget.scaleY, thisTarget.scaleZ);
        Handles.DrawWireCube(thisTarget.transform.position, new Vector3(maxAxisSize, maxAxisSize, maxAxisSize));

    }

    private void UpdateBoundaries(float scaleX_right, float scaleX_left, float scaleY_top, float scaleY_bottom, float scaleZ_front, float scaleZ_back)
    {
        NavCloudBoundaries thisTarget = (NavCloudBoundaries)target;
        float previousScaleX = thisTarget.scaleX;
        float previousScaleY = thisTarget.scaleY;
        float previousScaleZ = thisTarget.scaleZ;

        // X change //
        if ( (scaleX_right != previousScaleX) || (scaleX_left != previousScaleX))
        {
            float newValue = scaleX_right;
            Vector3 sideChange = Vector3.right;

            if (scaleX_left != previousScaleX) // If the change was left, instead of right
            {
                newValue = scaleX_left;
                sideChange = Vector3.left;
            }

            float sizeDiff = newValue - thisTarget.scaleX;
            thisTarget.scaleX = newValue;
            thisTarget.transform.Translate(sideChange* (sizeDiff * 0.5f));
            
        }

        // Y change //
        else if ((scaleY_top != previousScaleY) || (scaleY_bottom != previousScaleY))
        {
            float newValue = scaleY_top;
            Vector3 sideChange = Vector3.up;

            if (scaleY_bottom != previousScaleY) // If the change was bottom, instead of top
            {
                newValue = scaleY_bottom;
                sideChange = Vector3.down;
            }

            float sizeDiff = newValue - thisTarget.scaleY;
            thisTarget.scaleY = newValue;
            thisTarget.transform.Translate(sideChange * (sizeDiff * 0.5f));
           
        }

        // Z change //
        else if ((scaleZ_front != previousScaleZ) || (scaleZ_back != previousScaleZ))
        {
            float newValue = scaleZ_front;
            Vector3 sideChange = Vector3.forward;

            if (scaleZ_back != previousScaleZ) // If the change was back, instead of forward
            {
                newValue = scaleZ_back;
                sideChange = Vector3.back;
            }

            float sizeDiff = newValue - thisTarget.scaleZ;
            thisTarget.scaleZ = newValue;
            thisTarget.transform.Translate(sideChange * (sizeDiff * 0.5f));

        }
    }

}
#endif
