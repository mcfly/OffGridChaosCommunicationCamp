// Copyright Semaeopus Ltd. 2017
// This code was created as part of LevelKit on: 2019-11-26 - 9:25
// DO NOT EDIT THIS FILE - Code changes will NOT be picked up and may break your project
// Visit http://wiki.offgridthegame.com for help - Happy Hacking!

using System.Collections.Generic;
using UnityEngine;

[DisallowMultipleComponent]
public class InterestPoint : MonoBehaviour, ISerializationCallbackReceiver
{

    [HideInInspector]
    public string interestType = string.Empty;
    
    public bool isHacked = false;       

    public GameObject userPosition;

#if GAME_CORE
    [HideInInspector][System.NonSerialized] public AIGesture normalGesture = AIGesture.None;
    [HideInInspector][System.NonSerialized] public AIGesture failGesture = AIGesture.None;

    public bool inUse { get { return user != null; } }
    private GoapAction user = null;
    
    // If the interest point is hackable then this will be valid
    [HideInInspector]
	public Hackable device = null;

	public static Dictionary<string, List<InterestPoint>> interestPoints = null;

    private void OnEnable()
    {
        MissionRunnerBase.OnMissionStarted += OnMissionStarted;
    }

    private void OnDisable()
    {
        MissionRunnerBase.OnMissionStarted -= OnMissionStarted;
    }

    private void OnMissionStarted()
    {
        device = GetComponent<Hackable>();

        if (interestPoints == null)
        {
            interestPoints = new Dictionary<string, List<InterestPoint>>(32);

            foreach (InterestPoint point in FindObjectsOfType<InterestPoint>())
            {
                if (!interestPoints.ContainsKey(point.interestType))
                {
                    interestPoints[point.interestType] = new List<InterestPoint>(16);
                }

                interestPoints[point.interestType].Add(point);
            }
        }
    }
	
	public static InterestPoint FindClosestOfType(Vector3 fromPoint, string type) 
	{
		InterestPoint closestInterestPoint = null;
		if (interestPoints != null && interestPoints.ContainsKey(type))
		{
			// Select all InterestPoints of the right type:
			List<InterestPoint> suitablePoints = interestPoints[type];
			closestInterestPoint = FindClosestFromList(fromPoint, suitablePoints);

		}
		return closestInterestPoint;
	}

	public static List<InterestPoint> FindAllPointsOfType(string type)
	{
		return interestPoints[type];
	}

	public static List<InterestPoint> FindAllWorkingPointsOfType(string type)
	{
	    List<InterestPoint> result = new List<InterestPoint>();
	    if (interestPoints != null && interestPoints.ContainsKey(type))
	    {
	        foreach (InterestPoint point in interestPoints[type])
	        {
	            // If the point has a device than we'll check it's on and not amok
	            if (point.device != null
	                && point.device.GetPower()
	                && !point.device.GetAmok())
	            {
	                result.Add(point);
	            }
	            else if (point.device == null)
	            {
	                result.Add(point);
	            }
	        }
	    }
	    return result;
	}

	public static InterestPoint FindClosestWorkingPointOfType(Vector3 pos, string type)
	{
        return FindClosestFromList(pos, FindAllWorkingPointsOfType(type));
	}

	private static InterestPoint FindClosestFromList(Vector3 fromPoint, List<InterestPoint> pointList)
	{
		InterestPoint closestInterestPoint = null;

		// Pick the closest suitable point:
		// TODO: Do this using navigation mesh instead of absolute distance...
		float distanceToClosestPoint = float.MaxValue;
		foreach (InterestPoint iPoint in pointList)
		{
            if (iPoint.inUse)
                continue;

			float distanceToPoint = Vector3.Distance(fromPoint, iPoint.transform.position);
			float deltaY = Mathf.Abs(fromPoint.y - iPoint.transform.position.y);
			if (distanceToPoint < distanceToClosestPoint && deltaY < 2.0f)
			{
				closestInterestPoint = iPoint;
				distanceToClosestPoint = distanceToPoint;
			}
		}
		
		return closestInterestPoint;

	}

    public bool Use(GoapAction requester)
    {
        if (inUse)
            return false;

        user = requester;
        return true;
    }

    public void Relinquish(GoapAction finished)
    {
        if (user == finished)
        {
            user = null;
        }
    }

    public bool WillPrefer(string tag)
    {
        HackableObjectNetDevice device = GetComponent<HackableObjectNetDevice>();
        Personality p = GetComponent<Personality>();
        if(device != null && p != null)
        {
            List<string> profileForTag = p.GetProfileByTag(tag);
            if (profileForTag.Count > 0)
            {
                return device.WillPrefer(profileForTag);
            }
        }

        return false;
    }

#endif // GAME_CORE

    public void OnDrawGizmos()
	{
		Collider col = GetComponent<Collider>();
		Vector3 gizPos = transform.position;
		if (col)
		{
			gizPos = col.bounds.center;
		}
		
		Gizmos.DrawIcon(new Vector3(gizPos.x, gizPos.y, gizPos.z),
			"InterestPoint", true);
	}

    public void OnBeforeSerialize()
    {

    }

    public void OnAfterDeserialize()
    {

    }
}
